<!DOCTYPE html><html lang="en" itemscope itemtype="http://schema.org/Article"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content=""><meta itemprop="name" content="User Manual"><meta itemprop="description" content=""><meta itemprop="image" content="http://rtxi.org/assets/img/rtxi-logo-square.png"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="User Manual"><meta name="twitter:description" content=""><meta name="twitter:image:src" content="http://rtxi.org/assets/img/rtxi-logo-square.png"><meta property="og:title" content="User Manual"><meta property="og:type" content="article"><meta property="og:url" content="http://rtxi.org/docs/manual/"><meta property="og:image" content="http://rtxi.org/assets/img/rtxi-logo-square.png"><meta property="og:description" content=""><meta property="og:site_name" content="RTXI | The Real-time eXperiment Interface"><meta property="article:section" content="docs"><meta property="article:tag" content=""><title>User Manual | The Real-time eXperiment Interface</title><link href="/assets/css/default.min.css" rel="stylesheet"><style>#sidebar.affix-top { position: static; margin-top: 30px; }
#sidebar.affix { position: fixed; top:70px; }
img { margin-left: auto; margin-right: auto; margin-top: 5px; margin-bottom: 5px; display: block; max-width: 100%; height: auto; }
.nav .active { font-weight: bold; }
.nav .nav { display: none; }
.nav .active .nav { display: block; }
.nav .nav a { font-weight: normal; font-size: .85em; }
.nav .nav span { margin: 0 5px 0 2px; }
.nav .nav .active a, .nav .nav .active:hover a, .nav .nav .active:focus a { font-weight: bold; }
.nav .nav .active span, .nav .nav .active:hover span, .nav .nav .active:focus span { display: none; }</style><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="icon" href="/favicon.ico"></head><body><nav class="navbar navbar-inverse navbar-fixed-top" role="navigation"><div class="container"><div class="navbar-header"><button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" rel="home" href="/"><b>RTXI</b></a></div><div class="row"><div id="navbar" class="navbar-collapse collapse navbar-right" style="text-align:center"><ul class="nav navbar-nav"><li><a href="/install/">Install</a></li><li><a href="/modules/">Modules</a></li><li><a href="/papers/">Papers</a></li><li class="active"><a href="/docs/">Docs</a></li><li><a href="/stats/">Stats</a></li><li><a href="/community/">Community</a></li><li><a href="/contact/">Contact</a></li><li><a href="/feed.xml"><i class="fa fa-rss fa-inverse"></i></a></li></ul></div></div></div></nav><div style="padding-top:30px"><div class="container"><div class="row" id="topblock"><div class="col-xs-12"><h2 class="page-header">User Manual</h2></div></div><div class="row"><nav class="col-sm-3 col-lg-2 hidden-xs" id="leftCol"><ul class="nav" id="sidebar" data-spy="affix"><li><a href="#intro">Introduction</a></li><li><a href="#overview">Overview</a></li><li><a href="#dynamic_clamp">Dynamic Clamp</a></li><li><a href="#hardware">Hardware Specs</a></li><li><a href="#daqs">DAQs</a></li><li><a href="#rt_performance">Real-time Performance</a></li><li><a href="#menus">RTXI Menu</a></li><li><a href="#core_modules">System Modules</a><ul class="nav collapse" style="padding-left:20px"><li><a href="#control_panel">Control Panel</a></li><li><a href="#oscilloscope">Oscilloscope</a></li><li><a href="#data_recorder">Data Recorder</a></li><li><a href="#connector">Connector</a></li><li><a href="#rt_benchmarks">RT Benchmarks</a></li></ul></li><li><a href="#user_modules">User Modules</a></li><li><a href="#customizing_gui">Plugin Template</a></li><li><a href="#hdf">HDF Files</a></li></ul></nav><div class="col-sm-9 col-lg-10"><div id="intro" style="padding-top:30px; margin-top:-30px"><h3 class="page-header">About RTXI</h3><p>The Real-Time eXperiment Interface (RTXI) is a collaborative open-source software development project aimed at producing a real-time Linux based software system for hard real-time data acquisition and control applications in biological research. RTXI merges three previous systems for closed-loop biological experiments: <a href="http://archive.linuxgizmos.com/ldfiles/article032/c01_culianu.pdf">RTLab</a>, <a href="http://www.ncbi.nlm.nih.gov/pubmed/11764320">Real-time Linux Dynamic Clamp (RTLDC)</a>, and <a href="https://neurolab.gatech.edu/mrci">Model Reference Current Injection (MRCI)</a>. RTLDC and MRCI focus on implementing dynamic clamp, an experimental technique in cardiac and neural electrophysiology that is used to simulate ionic membrane currents. RTXI combines the features of all three predecessor platforms into a more general platform for real-time closed-loop experimental protocols. Using real-time control, scientists can quantify biological function via perturbations that change according to closed-loop analysis of measured system variables, rather than being restricted to measuring responses to pre-determined stimuli. Real-time control applications are abundant throughout biological research, including, for example, dynamic probing of ion-channel function, control of cardiac arrhythmia dynamics, and control of deep-brain stimulation patterns. There is a wide range of biological research endeavors for which real-time control can offer insight that cannot be obtained with traditional methods.</p><p>RTXI is based on Linux, which is extended with <a href="https://xenomai.org/">Xenomai</a> to provide a hard real-time platform with the comprehensive Linux desktop environment. Data acquisition and analog/digital interfaces to other hardware are implemented in real-time using the Analogy real-time driver interface, which provides support to a variety of commercial multifunction data acquisition cards. Experimental protocols and other real-time algorithms are implemented within a modular framework that allows users to easily reuse existing code and construct complex protocols. Users can also take advantage of previously written code or other <code>cpp</code> libraries to add functionality to their modules. As such, RTXI is a generic real-time platform with potential applications beyond dynamic clamp.</p><p>RTXI is released under a combination of the GPL and LGPL licenses. The core RTXI code is covered by a GPL license but user modules distributed as binary libraries are covered under LPGL and their source code may be available at the discretion of the original authors. All documentation is released under the GNU Free Documentation License.</p><p>If your use of RTXI leads to scientific publication, we request that you cite RTXI in your paper with text such as:</p><div class="well">Experiments were performed using the Real-Time eXperiment Interface (RTXI; www.rtxi.org).</div></div><div id="overview" style="padding-top:30px; margin-top:-30px"><h3 class="page-header">Overview</h3><p>RTXI contains many features that enable users to quickly implement complex interactive experimental protocols:</p><ul><li>Modular signal-and-slots architecture that allows multiple instantiations of user modules, makes it easy to reuse code such as event detection and online analysis algorithms, and allows branching logic so that signals (such as acquired data) can be routed through multiple algorithms in parallel</li><li>Data acquisition system that can stream multiple channels of acquired or computed data along with experimental metadata and user comments with timestamps</li><li>Ability to interface with a variety of multifunction DAQ cards and external hardware through analog or digital channels, e.g. via TTL pulses</li><li>Ability to change experimental parameters on-the-fly without recompiling or stopping real-time execution</li><li>Ability to save and reload your entire working environment with custom parameter settings</li><li>Virtually no limit to algorithms that can be implemented since user modules are written in cpp</li><li>Real-time digital oscilloscope that can plot any acquired or computed signal</li><li>Base class for constructing user modules with a customized graphical user interface to experimental protocols</li><li>Ability to 'play back' previously acquired data or surrogate data as if it were being acquired in real-time for debugging or simulation purposes</li><li>A complete simulation platform that can be used to solve systems of differential equations in real-time and integrate biological signals acquired in real-time with model systems</li></ul><p>In addition, RTXI is available on a Live CD, which provides a complete real-time Linux operating system with RTXI without installing anything on your computer. This live environment allows you to mount your existing hard drive and you can conduct experiments and collect data. Note that the real-time performance will be slower compared with an actually installed system. Running the live environment from a USB flash drive is faster than from an actual CD. A DAQ card does not need to be installed for RTXI to run and RTXI can be successfully run on many laptops, including Intel MacBooks and MacBook Pros.</p></div><div id="dynamic_clamp" style="padding-top:30px; margin-top:-30px"><h3 class="page-header">Introduction to Dynamic Clamp</h3><p>Traditionally, the properties of electrically excitable cells are assessed using current clamp and voltage clamp electrophysiology protocols. In <b>current clamp</b>, an electrical current waveform is specified and applied to the cell through a microelectrode while the transmembrane potential is recorded. In <b>voltage clamp</b>, a desired voltage waveform is specified and analog circuitry is used to determine and inject a current that is necessary to maintain, or clamp, the membrane potential at the specified values. The <b>dynamic clamp</b> allows the insertion of artificial membrane conductances, such as ion channels, by injecting current that is a function of the cell's membrane potential. The injected current is computed by computer software or analog circuitry based on the equivalent circuit model of an excitable cell (Fig. \ref{fig:circuit}). The artificial conductance is effectively in parallel with other membrane processes, each of which contributes to the total transmembrane current.</p><figure class="figure"><img src="/assets/img/manual/dclampcircuit.svg" class="figure-img img-fluid"><figcaption class="figure-caption">Equivalent circuit model of an excitable cell where <em>V<sub>m</sub></em> represents the transmembrane potential, <em>C<sub>m</sub></em> represents the membrane capacitance, and each conductance is defined by a reversal potential <em>E<sub>i</sub></em> and a conductance <em>g<sub>i</sub></em>. In this model, the voltage-dependent sodium and potassium ion channels are depicted as variable resistors where <em>g<sub>i</sub></em>=<em>g<sub>i</sub></em>(<em>V<sub>m</sub>)</em> . The reversal potential (or equilibrium potential) of an ion is the value of transmembrane voltage at which diffusive and electrical forces counterbalance, so that there is no net ion flow across the membrane. The reversal potential is represented as a battery since the potential difference <em>V<sub>m</sub></em>-<em>E<sub>i</sub></em> gives the driving force across the membrane for that ionic current.</figcaption></figure><p>The total transmembrane current is related to changes in the membrane potential, <em>V<sub>m</sub></em>, through the following equation:</p><p class="lead"><center><em>C<sub>m</sub></em> <em>dV<sub>m</sub></em>/<em>dt</em> = -&Sigma; <em>I<sub>i</sub></em></center></p><p>where <em>C<sub>m</sub></em> is the membrane capacitance. Any conductance that can be described mathematically can be applied to a neuron using the dynamic clamp. The current passing through an ion channel, for example, is often described by Ohm's law using the following conductance-based equation:</p><p class="lead"><center><em>I<sub>i</sub></em> = <em>g<sub>i</sub></em> <em>V<sub>m</sub></em>(<em>V<sub>m</sub></em>-<em>E<sub>i</sub></em>)<br><br><em>g<sub>i</sub></em><em>V<sub>m</sub></em> = <em style="text-decoration:overline">g<sub>i</sub></em> <em>m<sup>p<sub>h<sup>q</sup></sub></sup></em></center></p><p>where <em style="text-decoration:overline">g</em> is the maximal conductance, and <em>m</em> and <em>h</em> are voltage-dependent activation and inactivation gating variables (<em>p</em> and <em>q</em> are integers) that describe the kinetic activation of the channel. Gating variables have values between 0 and 1 to scale the channel conductance and are typically described by a first order differential equation:</p><p class="lead"><center><em><sup>dx</sup>/<sub>dt</sub></em> = <em><sup>x<sub>&infin;</sub>V<sub>m</sub>-x</sup> / <sub>&tau;V<sub>m</sub></sub></em></center></p><p>The membrane potential is re-sampled and the equations are re-evaluated on every computational cycle of the dynamic clamp system. As such, the dynamic clamp is also sometimes termed <b>conductance clamp</b> or <b>conductance injection</b>.</p><p>While the dynamic clamp was first demonstrated in cardiac electrophysiology to <a href="/papers/2006/07/27/dynamic-clamp-powerful-tool-in-cardiac-electrophysiology/">electrically couple embryonic chick myocytes</a>, the technique was independently introduced (<a href="http://dx.doi.org/10.1016/0165-0270(93)90119-C">Robinson, 1993</a> and <a href="http://jn.physiology.org/content/69/3/992">Sharp, 1993</a>) and is now more prevalent in neural electrophysiology (<a href="http://dx.doi.org/10.1523/JNEUROSCI.5954-09.2010">Economo, 2010</a>; <a href="http://dx.doi.org/10.1016/j.tins.2004.02.004">Prinz, 2014</a>; and <a href="http://dx.doi.org/10.1152/physiol.00063.2005">Goaillard, 2006</a>). Applications of this technique include the insertion of non-native ion channels (a virtual "knock-in"), subtraction of native ion channels (a virtual "knock-out"), and simulation of synapses and electrical gap junctions to create small networks of biological and/or simulated neurons. By varying the parameter values of a model channel or synapse, experiments can be conducted to determine how these properties shape membrane dynamics and neuron activity. These approaches have made the dynamic clamp a valuable tool for studying the intrinsic properties of single neurons and the behavior of small neural networks.</p><p>Dynamic clamp studies have also made important contributions to our understanding of neuronal dynamics under in vivo-like conditions in which neurons receive a constant barrage of synaptic inputs which can easily reach thousands of events per second. Artificial synaptic input can be constructed from pre-recorded activity of presynaptic neurons but is more commonly based on statistical descriptions of noisy conductance waveforms. This high conductance state has been shown to enhance the cell's responsiveness to small inputs, also known as its gain (<a href="http://dx.doi.org/10.1016/S0896-6273(02)00820-6">Chance, 2002</a>; <a href="http://dx.doi.org/10.1038%2Fnrn1198">Destexhe, 2003</a>; and <a href="http://dx.doi.org/10.1152/jn.00023.2010">Sceniak, 2010</a>), and can change the signal integration of synaptic input, creating distinct modes of firing patterns (<a href="http://dx.doi.org/10.1038/nn1591">Wolfart, 2005</a>; <a href="http://jn.physiology.org/content/86/1/1.short">Steriade, 2001</a>; <a href="http://dx.doi.org/10.1023/A:1023245625896">Rudolph, 2003</a>; and <a href="http://dx.doi.org/10.1016/S0306-4522(01)00344-X">Destexhe, 2001</a>). The statistics of current-based versus conductance-based input, such as correlations and relative balance between excitation and inhibition, are translated differently into output statistics such as the membrane potential distribution, the distribution of interspike intervals (ISIs), the coefficient of variation (CV), and the mean and variance of the neuron's output firing rate (<a href="http://dx.doi.org/10.1103/PhysRevE.62.8413">Tiesinga, 2000</a>; <a href="http://www.jneurosci.org/content/23/6/2466">Rudolph, 2003</a>; <a href="http://dx.doi.org/10.1162/neco.2008.20.1.1">Kumar, 2008</a>; and <a href="www.jneurosci.org/content/20/16/6193">Salinas, 2000</a>). Together, these factors result in a dynamical behavior of the neuron that is usually quite different from the intrinsic dynamics of the voltage-gated currents.</p><p>Results from dynamic clamp experiments must be carefully interpreted due to several experimental limitations. Space-clamp problems arise in that the injected current is limited to a space around the recording electrode. In some experimental studies, an artificial dendrite is modeled as well to simulate the cable effects of synaptic inputs propagating to the action potential initiation zone (<a href="http://dx.doi.org/10.1016/j.jneumeth.2007.10.014">Hughes, 2008</a>). Since current can usually only be injected at the soma, the dynamic clamp may be a poor approximation of dendritic input in some cell types. In most cells, the dynamic clamp is operated in discontinuous current clamp (DCC) mode in which a single electrode switches between recording and current injection states. In this configuration, it is not possible to inject large conductances that approach the magnitude of the cell's intrinsic resting conductance while still accurately recording the membrane potential. The injected current induces a voltage drop through the electrode and causes measurement accuracies that are propagated through the closed feedback loop in the dynamic clamp system and may cause ringing artifacts in the recording (<a href="http://dx.doi.org/10.1113/jphysiol.2003.059964">Brizzi, 2004</a>; <a href="http://www.jneurosci.org/content/19/14/6090">Jaeger, 1999</a>; <a href="http://dx.doi.org/10.1109/IEMBS.2007.4352315">Preyer, 2007</a>; and <a href="http://dx.doi.org/10.1109/TNSRE.2009.2015205">Preyer, 2009</a>). In larger cells, two electrodes may be used, one to record and one to inject current. Researchers also typically use the same ion channel or synapse model parameters for all cells used in an experiment, assuming that neurons of the same cell type have identical intrinsic properties, both within an animal and between animals (<a href="http://jn.physiology.org/content/87/2/1129">Golowasch, 2002</a>). There usually is not time during an experiment to manually adjust the model to optimal parameters for each cell.</p><p>Compared to other real-time closed-loop experimental protocols, the dynamic clamp has perhaps the most stringent performance requirements. These limitations involve numerical, algorithmic, and hardware platform-specific issues. Dynamic clamp performance depends on how accurately the model is solved, measurement error in sampling the voltage, and the sampling rate of the system. \index{sampling rate}The sampling rate determines how much time is in a given computational cycle for various operations to be performed, and the duration of the cycle restricts the types of numerical methods that may be used to integrate the gating variables. Thus, the computational performance of dynamic clamp suffers from a trade-off between the speed of computation and numerical accuracy. Dynamic clamp sampling rates are currently chosen based on the limits of the hardware platform being used and the temporal dynamics being simulated. While it is possible to compute the time step necessary for the Euler and exponential Euler methods to achieve a desired one-step integration accuracy for a known voltage measurement error, few studies employ this technique (<a href="http://dx.doi.org/10.1088/1741-2560/1/4/001">Butera, 2004</a>). In simulations of dynamic clamp, Euler integration was insufficient to model fast sodium Na<em><sub>v</sub></em> channels at sampling rates under 30 kHz and nearly identical integration results for three different deterministic integration methods was only achieved at rates >=50 kHz (<a href="http://dx.doi.org/10.1529/biophysj.107.118190">Milescu, 2008</a>). Standard performance benchmarks are needed for dynamic clamp to justify the sampling rates that are used.</p><p>Other hardware that are typically required for dynamic clamp are an electrophysiology amplifier for measuring membrane potential and injecting current and a multifunctional data acquisition system (DAQ) for performing analog-to-digital (ADC) and digital-to-analog (DAC) conversion. The technical specifications of each of these hardware components can affect the performance of the overall system by introducing additional jitter, latency, and quantization error that can affect system timing and the numerical computation (<a href="http://dx.doi.org/10.1016/j.jneumeth.2007.10.009">Bettencourt, 2008</a> and <a href="http://dx.doi.org/10.1109/10.966605">Butera, 2001</a>). Recent results show that faster systems would result in a greater range of conductances that could be utilized, improved stability, and more accurate real-time model simulations (<a href="http://dx.doi.org/10.1109/IEMBS.2007.4352315">Preyer, 2007</a> and <a href="http://dx.doi.org/10.1109/TNSRE.2009.2015205">Preyer, 2009</a>). Faster dynamic clamp systems have been developed, largely due to the increasing power of personal computers, but also due to the development of systems based on the GNU/Linux operating system and embedded real-time processors.</p></div><div id="hardware" style="padding-top:30px; margin-top:-30px"><h3 class="page-header">Hardware Requirements</h3><p>RTXI is designed to run on a standard personal desktop computer. Computers with uniprocessors, multi-core processors, and multiple CPUs with and without hyperthreading are supported by Linux and RTXI, though typically more stable systems are realized with Intel rather than AMD processors. For multi-core computers, Xenomai will need to be manually configured during installation. In rare cases, a particular CPU and motherboard combination is not supported. Certain advanced motherboards may contain features that are not compatible with Xenomai, such as some integrated graphics chips that use hardware-level techniques to speed up computation. For video cards, we recommend you use an external one. Generally, NVIDIA cards have better Linux support than ATI/Radeon ones. This distinction is important because the greatest overhead in RTXI is related to data visualization in the oscilloscope. For newer graphics cards, you may need to manually install the Linux drivers, usually available on the manufacturer's website. Some systems may also include BIOS level or hardware interrupts that are not captured by Xenomai or advanced power management features. Sometimes these can be disabled by the user in the BIOS.</p><p>The real-time Linux kernel has extremely low latencies and little software overhead. RTXI is also designed to minimize the number of dynamically loaded modules and keep overhead low. RTXI has been successfully tested on computers with Pentium III processors up to 4(8)-core Intel i7 processors. While the processor speed allows RTXI to complete more computations within a single real-time cycle, the amount of RAM and the amount of video memory have a significant impact on the stability and speed of the system. Users should also consider high speed hard drives, large cache sizes, and high speed bus interfaces. If you are purchasing an off-the-shelf desktop computer system and plan to add a DAQ card, be sure that your power supply is powerful enough to handle the extra load. At least a 450W power supply is recommended.</p></div><div id="daqs" style="padding-top:30px; margin-top:-30px"><h3 class="page-header">Data Acquisition Cards</h3><p>For closed loop experiments using RTXI, your computer must be equipped with an analog-to-digital converter (ADC) to acquire data and a digital-to-analog converter (DAC) to generate signals. Of course, external hardware such as an oscilloscope or function (waveform) generator can be used in conjunction with RTXI. A popular option is to purchase a commercial multifunction data acquisition card that provides analog input and output, digital input and output, and counter/timer circuitry. DAQ cards using the USB interface are <i>not compatible</i> with RTXI because USB drivers in Linux are not capable of hard real-time operation. Furthermore, the USB interface can only achieve a maximum sampling rate of approximately 1 kHz, insufficient for some closed-loop real-time applications. Many DAQ cards using the PCI, PCI express, or PXI interface are available from a variety of manufacturers. Your choice of DAQ card should depend on the number of analog and/or digital channels that you need, the amount of data resolution (eg. 12, 16-bit), sampling resolution, speed, and whether you need simultaneous or sequential sampling of multiple input channels.</p><p>Most RTXI users use products developed by National Instruments. ANALOGY, a set of drivers derived from ANALOGY, provides support for many NI DAQs, for low-level drivers for cards using a 8255 chip for three channels of 8 bit digital input or output, and for standard PC parallel ports. A list of currently supported NI cards and their corresponding ANALOGY driver and other ANALOGY-supported DAQ manufacturers is given below.</p><div class="table-responsive"><table class="table table-striped"><thead><tr><th>Manufacturer</th><th>Website</th></tr></thead><tbody><tr><td>ADLINK</td><td><a href="http://www.adlinktech.com">http://www.adlinktech.com</a></td></tr><tr><td>Advantech</td><td><a href="http://www.advantech.com">http://www.advantech.com</a></td></tr><tr><td>Amplicon</td><td><a href="http://www.amplicon.com">http://www.amplicon.com</a></td></tr><tr><td>Data Translation</td><td><a href="http://www.datatranslation.com">http://www.datatranslation.com</a></td></tr><tr><td>Fastwel</td><td><a href="http://www.fastwel.com">http://www.fastwel.com</a></td></tr><tr><td>General Standards Corporation</td><td><a href="http://www.generalstandards.com">http://www.generalstandards.com</a></td></tr><tr><td>ICP</td><td><a href="http://www.icpdas-usa.com">http://www.icpdas-usa.com</a></td></tr><tr><td>Intelligent Instrumentation</td><td><a href="http://www.instrument.com">http://www.instrument.com</a></td></tr><tr><td>Keithley Instruments</td><td><a href="http://www.keithley.com">http://www.keithley.com</a></td></tr><tr><td>Measurement Computing</td><td><a href="http://www.mccdaq.com">http://www.mccdaq.com</a></td></tr><tr><td>National Instruments</td><td><a href="http://www.ni.com/dataacquisition">http://www.ni.com/dataacquisition</a></td></tr></tbody><caption>DAQ manufacturers with ANALOGY-supported hardware</caption></table></div><div class="table-responsive"><table class="table table-striped"><thead><tr><th>Driver</th><th>Devices</th></tr></thead><tbody><tr><td><code>analogy_ni_pcimio</code></td><td>PCI-MIO-16XE-50, PCI-MIO-16XE-10, PCI-MIO-16E-1, PCI-MIO-16E-4, PCI-6014, PCI-6023E, PCI-6024E, PCI-6025E, PXI-6025E, PCI-6030E, PXI-6030E, PCI-6031E, PCI-6032E, PCI-6033E, PCI-6034E PCI-6035E, PCI-6036E, PCI-6040E, PXI-6040E, PCI-6052E, PXI-6052E, PCI-6070E, PXI-6070E, PCI-6071E, PXI-6071E, PCI-6110, PCI-6111, PCI-6220, PCI-6221, PCI-6143, PXI-6143, PCI-6224, PCI-6225, PCI-6229, PCI-6250, PCI-6251, PCIe-6251, PCI-6254, PCI-6259, PCIe-6259, PCI-6280, PCI-6281, PXI-6281, PCI-6284, PCI-6289, PCI-6711, PXI-6711, PCI-6713, PXI-6713, PCI-6731, PCI-6733, PXI-6733</td></tr><tr><td><code>s526</code></td><td>No information available</td></tr><tr><td><code>parport</code></td><td>No information available</td></tr><tr><td><code>8255</code></td><td>No information available</td></tr></tbody><caption>ANALOGY-supported NI DAQ cards</caption></table></div><h4 class="page-header">Adding more DAQ cards</h4><p>RTXI has no built-in software limitations on the number of DAQ cards but is configured for only one card by default. If you want to use additional cards, you will need to edit the configuration file. Here is the relevant excerpt of <code>/etc/rtxi.conf</code>:</p><figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;OBJECT</span> <span class="na">component=</span><span class="s">"plugin"</span> <span class="na">library=</span><span class="s">"analogy_driver.so"</span> <span class="na">id=</span><span class="s">"2"</span><span class="nt">&gt;</span>
<span class="nt">&lt;PARAM</span> <span class="na">name=</span><span class="s">"0"</span><span class="nt">&gt;</span>/dev/analogy0<span class="nt">&lt;/PARAM&gt;</span>
<span class="nt">&lt;PARAM</span> <span class="na">name=</span><span class="s">"Num Devices"</span><span class="nt">&gt;</span>1<span class="nt">&lt;/PARAM&gt;</span>
<span class="nt">&lt;OBJECT</span> <span class="na">id=</span><span class="s">"13"</span> <span class="na">name=</span><span class="s">"0"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/OBJECT&gt;</span></code></pre></figure><p>Edit the lines to add another ANALOGY device and change the number of devices:</p><figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;PARAM</span> <span class="na">name=</span><span class="s">"0"</span><span class="nt">&gt;</span>/dev/analogy0<span class="nt">&lt;/PARAM&gt;</span>
<span class="nt">&lt;PARAM</span> <span class="na">name=</span><span class="s">"1"</span><span class="nt">&gt;</span>/dev/analogy1<span class="nt">&lt;/PARAM&gt;</span>
<span class="nt">&lt;PARAM</span> <span class="na">name=</span><span class="s">"Num Devices"</span><span class="nt">&gt;</span>2<span class="nt">&lt;/PARAM&gt;</span></code></pre></figure><p>You will need to exit and restart RTXI for the new configuration to take effect. Settings files that you have already created should still work when you change <code>rtxi.conf</code> but you may not have access to both DAQ cards in the System Control Panel, the Oscilloscope, and the Connector. You will have to rebuild those settings files or edit them as above using your choice of text editor.</p><p>RTXI automatically detects the manufacturer and board names of available DAQ cards and the number and type of input and output channels. The first DAQ card installed in your system is assigned the Linux device name: <code>/dev/analogy0</code>. Additional DAQ cards are assigned device names <code>/dev/analogy1</code> and so on. You can check that your DAQ card has been correctly detected and see the corresponding device name by clicking <b>Help</b> --> <b>About ANALOGY</b> from the RTXI menu bar.</p></div><div id="rt_performance" style="padding-top:30px; margin-top:-30px"><h3 class="page-header">Real-time Performance</h3><p>Xenomai provides several command line utilities for testing your real-time performance. These are available in your Xenomai installation directory at <code>/usr/xenomai/bin</code>). There are both user and kernel space versions of the available tools. When using these tests, keep in mind that they are most informative when the system is under processing loads, ideally loads similar to those added when you run RTXI.</p><p>The most important test is the latency test. It measures the latency, or the difference in time between the expected switch time and the time a task is actually called by the scheduler. It is essentially a measure of the delay when a task is supposed to run and when it actually runs. For a system to run in real-time, the latency values <strong>must</strong> be below the frequency at which a task must be run. For example, to run something in real-time at 20 kHz, the latencies must remain below 50 us. Failure to do so constitutes an overrun.</p><p>The latency test will perform latency calculations repeatedly (default 10 kHz) until stopped. To run, go to the <code>/usr/xenomai/bin</code> directory and execute: <code>$ sudo ./run</code>. To stop a running test, use <code>CTRL-C</code> in the terminal.</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">==</span> Sampling period: 100 us
<span class="o">==</span> Test mode: periodic user-mode task
<span class="o">==</span> All results <span class="k">in </span>microseconds
warming up...
RTT|  00:00:01  <span class="o">(</span>periodic user-mode task, 100 us period, priority 99<span class="o">)</span>
RTH|----lat min|----lat avg|----lat max|-overrun|---msw|---lat best|--lat worst
RTD|     -2.376|     -2.185|     -0.114|       0|     0|     -2.376|     -0.114
RTD|     -2.721|     -2.171|      0.100|       0|     0|     -2.721|      0.100
RTD|     -2.725|     -2.175|      1.223|       0|     0|     -2.725|      1.223
RTD|     -2.363|     -2.185|      0.416|       0|     0|     -2.725|      1.223
RTD|     -2.720|     -2.193|     -0.584|       0|     0|     -2.725|      1.223
RTD|     -2.527|     -2.144|      5.550|       0|     0|     -2.725|      5.550
RTD|     -2.272|     -2.193|     -1.120|       0|     0|     -2.725|      5.550
RTD|     -2.716|     -2.193|     -0.455|       0|     0|     -2.725|      5.550</code></pre></figure><p>The test prints one line every second and gives you the minimum, average, and maximum latencies for that period as well the minimum and maximum overall latencies that occurred over the entire test. Open up some other programs, copy some files from one location to another, and load the network connection to see how it affects the latency. The system's real-time performance is limited by the maximum latency (the 'lat worst' column). You should not any overruns, meaning that the latency completely exceeds the nominal period. Negative time values in the latency test is due to the fact that Xenomai performs a calibration at startup that tries to minimize the jitter in the real-time task and anticipates the call. You can correct this behavior by running (as root):</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># echo 0 &gt; /proc/xenomai/latency</span></code></pre></figure><p>There are many factors that affect your real-time performance, which do not necessarily depend on your absolute processor speed. For simple applications such as a single ion channel, similar results can be obtained on 200 MHz or 2 GHz processors. The limiting factors actually involve the design of the motherboard and chipset, the cost of reading and writing to a DAQ card, and the cost of accessing the hard disk when streaming data. Multi-processor systems or multicore processors also operate differently than single processors. RTXI allows the system to distribute processes among individual cores and does not assign any operations to particular cores. The user can use the <code>isolcpus</code> and <code>xeno_hal.supported_cpus</code> boot options to limit real-time operations to a single core and let all other non real-time operations be distributed among other available cores. Generally, you'll get the best RT performance from your system if you disconnect from your network, especially if is a wireless network, and to plot only the minimum number of signals in the Oscilloscope module as possible.</p><p>If you periodically see an overrun (perhaps every 64 seconds) that results in a maximum latency of several hundred microseconds, you may have an SMI (System Maintenance Interrupt) issue. This feature can be found on certain chipsets e.g. Intel 82845 845. Disabling SMI can cause some computers to overheat and may damage those computers. Other latency killers are: heavy DMA activities (using the hard disk), using an accelerated Xserver, USB legacy support, power management (APM and ACPI), and CPU frequency scaling. If you have disabled all of these in the kernel already, check your BIOS and see if you can disable them there.If you installed RTXI using our Live CD or installation instructions, these are already correctly configured.</p></div><div id="menus" style="padding-top:30px; margin-top:-30px"><h3 class="page-header">RTXI Menu</h3><p>Although RTXI is dependent on Linux, it is a complete desktop application and configuration of system settings and interaction with most features are available through a graphical user interface.</p><div class="row"><div class="col-md-6"><p>The <b>File Menu</b> is used to save and load settings files that capture the entire working environment. This includes settings configured in the System Control Panel, such as channel gains, parameters set within modules, and connections between modules. Reloading a settings files will also restore the window sizes and positions at the time the file was created. Recently used settings files are also available from this menu.</p></div><div class="col-md-6"><img src="/assets/img/manual/fileMenu.png" alt="RTXI files menu"></div></div><div class="row"><div class="col-md-6"><p>The <b>Modules Menu</b> is used to load user modules. User modules are shared libraries that are installed to <code>/usr/local/lib/rtxi</code> during the compilation process. Choosing "Load User Module" opens a file dialog box at this location, from where users may select modules based on the *.so filename.</p></div><div class="col-md-6"><img src="/assets/img/manual/modulesMenu.png" alt="RTXI modules menu"></div></div><div class="row"><div class="col-md-6"><p>The <b>System Menu</b> is used load core RTXI system features and modules. The Control Panel is used to configure channels and set the nominal system period (or sampling rate). The Oscilloscope is the digital oscilloscope that can be used to plot any signal in real-time. The Data Recorder allows users to select signals to stream to a HDF5 file in real-time. The Connector is used to specify connections between modules and the DAQ card. The Performance Measurement module displays running statistics on the computational load in RTXI. There is also a Preferences panel for specifying commonly used directories, etc.</p></div><div class="col-md-6"><img src="/assets/img/manual/systemMenu.png" alt="RTXI system menu"></div></div><div class="row"><div class="col-md-6"><p>The <b>Help Menu</b> contains important information about your system and RTXI. You can view the version number of your RTXI installation and the version of Qt used to build the user interface. Also included is a link to our documentation website and a link to our GitHub repository where you can report any issues you have with your system.</p></div><div class="col-md-6"><img src="/assets/img/manual/helpMenu.png" alt="RTXI help menu"></div></div></div><div id="core_modules" style="padding-top:30px; margin-top:-30px"><h3 class="page-header">Core System Modules</h3><p>The following modules are included in RTXI by default and are available through the <b>System</b> menu. All settings edited in each of these modules can be saved and reloaded via workspaces. Save by choosing <b>File</b> --> <b>Save Workspace</b> from the RTXI menu bar. This will create a basic *.set file that you can load in the future to recreate this environment or use as a foundation for additional *.set files.</p><h4 id="control_panel" class="page-header">System Control Panel</h4><p>The System Control Panel allows you to set important parameters on all the input and output channels of your DAQ card and set the nominal real-time period of your system. To keep the number of RT events to a minimum, all changes made in the Control Panel are not set until the <b>Apply</b> button is pressed.</p><img src="/assets/img/manual/systemcontrol0.png"><dl class="dl-horizontal"><dt>DAQ Setup</dt><dd><p>RTXI automatically detects the manufacturer and board names of available DAQ cards and the number and type of input and output channels. The first DAQ card installed in your system is assigned the Linux device name: <code>/dev/analogy0</code>. Additional DAQ cards are assigned device names <code>/dev/analogy1</code> and so on.</p><p>You can use either the <b>Frequency</b> or <b>Period</b> entry boxes to set the real-time period. After you enter the value, hit <b>Apply</b> to set your changes.</p></dd><dt>Analog<br>Channels</dt><dd><p>The <b>Channel</b> submenu lists all avaiable analog input and output channels for the specified DAQ device. Picking a particular channel will allow you to activate the channel and also set the parameters of that channel via the <b>Range</b>, <b>Scale</b>, and <b>Offset</b> menus below. To activate a channel (i.e. tell the DAQ driver to start reading/writing the channel), press down the <b>Active</b> button, and then hit <b>Apply</b>.</p><p>NOTE: If you do not hit the <b>Apply</b> button before changing channels, all changes made , such as the range, activation state, etc. will be lost.</p><p>The <b>Range</b>, <b>Scale</b>, and <b>Offset</b> submenus set the acquisition range and the reference mode. By default, RTXI assumes that all analog DAQ input and output channels have a range from -10 V to +10 V, unity gain (or a scaling of 1 V/V), a 0 V offset, and a ground reference. You must set the correct options for each channel you are using to acquire and output the correct signal values. Remember to hit <b>Apply</b> to set your changes.</p></dd><dt>Digital I/O</dt><dd>If you DAQ supports digital I/O, use this section of the control panel to activate individual channels. All you need to do is set whether the channel is to an input or an output, hit the <b>Active</b> button, and the hit <b>Apply</b>. For digital outputs, RTXI will output 0 V when 'false' and 5 V when 'true'.</dd></dl><h4 id="oscilloscope" class="page-header">Oscilloscope</h4><p>The Oscilloscope allows you to plot any system signal, such as signals from/to the DAQ card and signals from user modules. Each signal may have a different vertical scale and line style and a legend is automatically generated in the Oscilloscope window.</p><img src="/assets/img/manual/oscilloscope0.png"><dl class="dl-horizontal"><dt>Channel</dt><dt><dd><p>Select signals to plot from the dropdown menu. You can plot any input or output from a loaded module or active channel on your DAQ. DAQ signals will appear as an ANALOGY source, eg. <code>analogy0</code>. Be sure to check whether you have to set additional settings in the System Control panel to compensate from gains from any additional instrumentation. Input to the DAQ card from external instrumentation, such as an external amplifier, is designated as output from the DAQ card within RTXI. RTXI will automatically detect how many input and output channels your card has. Signals from other modules will be identified by the module name and you can choose from any inputs, outputs, parameters, or states that are defined in those modules.</p><p>Use the <b>Scale</b> and <b>Offset</b> options to modify the signals being plotted. To actually plot the signal, you must depress the <b>Active</b> toggle button and hit <b>Apply.</b> Any modifications you make to the scaling, offset, or line style of the signal are not active until you hit <b>Apply</b> again. Note that plotting too many signals in real-time may affect your system performance and cause your GUI to freeze during program execution. Use the RT Performance module to watch the load on your system while the Oscilloscope is running.</p></dd></dt></dl><img src="/assets/img/manual/oscilloscope1.png"><dl class="dl-horizontal"><dt>Time/Div</dt><dt><dd><p>Use the dropdown menu to set the time scale for the x-axis. Each "div" refers to the demarcations on the plot window. You can also set the refresh rate, or the number of times the plot window is refreshed per second, and you can set a downsampling rate for plotting.</p></dd></dt><dt>Edge</dt><dt><dd><p>Use the <b>Edge</b> option to set a trigger to freeze the oscilloscope when certain criteria are met by a specified channel. Set the trigger to operate on a rising or falling edge by clicking the <b>+</b> or <b>-</b> radio buttons, respectively. The <b>Channel</b> can be set to any active signal that is currently plotted on the oscilloscope. <b>Threshold</b> sets the threshold for the trigger channel you specified, and <b>Window</b> sets the amount of time that lapses before the trigger is reset again. The trigger threshold is indicated on the oscilloscope by a horizontal yellow dashed line.</p><p>To start the trigger, set everything in the menu and then hit the <b>Apply</b> button. To stop, select the <b>Off</b> radio button and hit <b>Apply</b> again.</p></dd></dt></dl><h4 id="data_recorder" class="page-header">Data Recorder</h4><p>The Data Recorder module allows users to stream synchronous data to a HDF5 file. Open the module by selecting <b>System</b> --> <b>Data Recorder</b> from the RTXI menu bar.</p><img src="/assets/img/manual/datarecorder1.png"><dl class="dl-horizontal"><dt>Channel<br>Selection</dt><dd><p>The <b>Block</b> menu is a list of your DAQ card(s) and any loaded user modules. Selecting a block device then populates the <b>Type</b> and <b>Channel</b> menus. Navigate the menus until you specify the channel you want to record. Then, hit <b>Add</b> to add the channel to the <b>Currently Recording</b> block. To remove a channel from the list, double-click its name in the list and then press the <b>Remove</b> button.</p><p><dt>File Control</dt><dd><p>Before you can start recording, you must select a file by clicking the <b>Choose File</b> button. Navigate to the directory where you want to save you file. From the menu, you can either create a new HDF file select an existing one. If you choose the latter, you can either append new data to the file, preserving any existing data, or you can simply overwite it, erasing any existing data and only saving new trials.</p><p>Click <b>Start Recording</b> to begin recording and <b>Stop Recording</b> to stop recording. For each module connected to the Data Recorder, it also grabs all the parameter values and saves them as metadata. In addition, it logs when any of these parameter values change so that you have a complete record of your experiment.</p><p>If you have a configuration such that Module A: Output 0 --> Module B: Input 0, saving Output 0 from Module A and Input 1 from Module B will give you exactly the same data. Similarly, saving <code>/dev/analogy0</code>: Analog Output 0 will save the signal that has been assigned to that channel (perhaps generated by a user module), not the actual signal the DAQ card is outputting. To check the actual output of the DAQ card, you will need to make a connection from that output to another input channel.</p></dd><dt>Trial Metadata</dt><dd><p>Each time you start and stop the data recorder counts as one 'trial'. By default, the Data Recorder displays the current trial number, the size of your data file, and the length of time from your last trial. "Trials" have to do with the data structure heirarchy within the HDF files. More information on what that means is provided <a href="#hdf">below</a>.</p></dd></p></dd></dl><h4 id="connector" class="page-header">Connector</h4><p>The Connector module allows you to create data streams between modules or between modules and the DAQ card.</p><img src="/assets/img/manual/connector.png"><dl class="dl-horizontal"><dt>Source</dt><dd><p>The Source block displays all Input channels from your DAQ and all OUTPUT variables from any open modules. The name of each module and analogy device is displayed in the <b>Block</b> drop-down menu, and the name of each analog/digital input channel or module output channel is displayed in <b>Channel</b>.</p><p>RTXI automatically detects how many inputs are available on your DAQ card. Note that the module does not check whether the channels are enabled via the Control Panel.</p></dd><dt>Destination</dt><dd><p>The Destination block displays all Output channels on your DAQ and all INPUT variables from any open modules. The name of each module and analogy device is displayed in the <b>Block</b> drop-down menu, and the name of each analog/digital output channel or module input channel is displayed in <b>Channel</b>.</p></dd><dt>Connections</dt><dd><p>To connect one module from the other, select the desired Source and Destination channel. Then, click <b>Connect</b>. Now, every real-time period, the value of the Source channel is read in as input for the Destination channel.</p><p>All active connections are listed in the <b>Connections</b> box. To remove an existing connection, double-click on its entry in the list and again click the <b>Connect</b>button.</p></dd></dl><h4 id="rt_benchmarks" class="page-header">Real-time Benchmarks</h4><p>The RT Benchmarks module gives you timing statistics for RTXI. For hard real-time performance, all operations must complete within the nominal system period. This module continuously keeps track of the time needed to complete these tasks, as well as the actual real-time period. In addition, the module reports the worst case total computation time and the worst case time step for however long the module was openor the statistics were last reset.</p><img src="/assets/img/manual/performancebenchmark0.png"><dl class="dl-horizontal"><dt>Comp Time</dt><dd><p>The time it takes for all RT components (system modules + <code>execute</code> loops from user modules) to run in a single RT cycle.</p></dd><dt>Peak Comp<br>Time</dt><dd><p>The peak computation time measured over the time the RT Benchmarks module was running or was last reset.</p></dd><dt>RT Period</dt><dd><p>The timestamp of the current RT period minus the timestamp from the last period. Basically, a measure of how long the previous period lasted. Ideally, this number is very close to the nominal RT period set in the Control Panel.</p></dd><dt>Peak RT<br>Period</dt><dd><p>The maximum RT Period measured over the time the RT Benchmarks module was running or was last reset.</p></dd><dt>RT Jitter</dt><dd><p>The standard deviation of all the real-time periods measured over the time since the RT Benchmarks module was opened or last reset.</p></dd></dl></div><div id="user_modules" style="padding-top:30px; margin-top:-30px"><h3 class="page-header">User Modules</h3><div class="row"><div class="col-xs-12 col-sm-8 col-lg-9"><p>Click the big, green button to the right and head to our Modules page. There, you'll find all the available user modules and instructions for how to download and install them.</p></div><div class="col-xs-12 col-sm-4 col-lg-3"><a href="/modules"><button type="button" class="btn btn-success btn-lg center-block">View Modules</button></a></div></div><p>RTXI comes with a set of core system modules but also enables users to install custom modules. All modules are compiled as Linux shared object libraries (*.so) that are linked into the core system. This allows RTXI to have minimal overhead and user modules are loaded only as needed. This architecture also allows multiple instantiations of user modules so that elements such as filters and event detectors can be reused on a variety of signals.</p><p>The compilation and installation process will create an RTXI shared object library (*.so extension) in <code>/usr/local/lib/rtxi</code>, where RTXI will initially look for them. User modules must be recompiled if any changes are made to their sources after installation. Note that when reinstalling modules, the corresponding *.so files are overwritten, so always make sure that different modules have unique names.</p></div><div id="customizing_gui" style="padding-top:30px; margin-top:-30px"><h3 class="page-header">DefaultGUI and the Plugin Template</h3><p>This is an explanation for the code found in the <a href="/modules/plugin-template">plugin template module</a> and a brief introduction to the DefaultGUI framework it abstracts. The plugin template contains starter code for building new RTXI modules, though you can fork <a href="/modules">any other module</a>, too. Below are the contents of <code>plugin-template.cpp</code> and <code>plugin-template.h</code>. Click on a code block to display an explanation of how its code works. If anything is unclear, <a href="https://github.com/rtxi/rtxi.github.io/issues">let us know</a>.</p><p>This tutorial will assume the reader has a basic understanding of C++, such as including libraries and source files, classes, inheritance, etc. For a quick run-down of C++ for people already familiar with programming, <a href="http://www.cplusplus.com/doc/tutorial/">this</a> is a decent place to start.</p><h4 class="page-header">plugin-template.h</h4><div><a data-toggle="collapse" data-target="#header1"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cm">/*
 * This is a template header file for a user modules derived from
 * DefaultGUIModel with a custom GUI.
 */</span>

<span class="cp">#include &lt;default_gui_model.h&gt;</span></code></pre></figure></a></div><div class="collapse" id="header1"><p><code>default_gui_model.h</code> is the header for the <code>DefaultGUIModel</code> class that <code>PluginTemplate</code> abstracts from. The file itself is stored in <code>include/default_gui_model.h</code> in the <a href="https://github.com/rtxi/rtxi">RTXI repository</a>. <code>DefaultGUI</code> is on its own a mechanism by which users can create their own plugins. <code>PluginTemplate</code> simply obscures some of the more arcane functions and provides a more simplified programming experience.</p></div><div><a data-toggle="collapse" data-target="#header2"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">PluginTemplate</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DefaultGUIModel</span> <span class="p">{</span>

   <span class="n">Q_OBJECT</span></code></pre></figure></a></div><div class="collapse" id="header2"><p>The <code>PluginTemplate</code> abstracts from <code>DefaultGUIModel</code> to fit within RTXI's framework. To fit within the Qt framework, it uses the <code>Q_OBJECT</code> macro, which tells Qt's meta-object compiler to insert code into the class that implement signals and slots. Signals and slots are how different <code>QObjects</code> communicate with one another. One <code>QObject</code> sends a signal that is received by another <code>QObject</code>'s slot. The <code>Q_OBJECT</code> macro indicates that the class is to be treated as a <code>QObject</code>.</p></div><div><a data-toggle="collapse" data-target="#header3"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">   <span class="nl">public:</span>

      <span class="n">PluginTemplate</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
      <span class="k">virtual</span> <span class="o">~</span><span class="n">PluginTemplate</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

      <span class="kt">void</span> <span class="n">execute</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
      <span class="kt">void</span> <span class="n">customizeGUI</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span></code></pre></figure></a></div><div class="collapse" id="header3"><p>The functions of the constructor and destructor should be obvious.</p><p>The <code>execute</code> function is used to run code within the real-time loop. In other words, whatever get's put in here will be run in real-time. Whatever is run here should be as time and memory-efficient as possible. After all, to run RTXI at high frequencies (40-50 kHz) the code must take microseconds to execute.</p><p>The <code>customizeGUI</code> function is used to add and edit UI elements on the display. By default, <code>DefaultGUI</code> creates widget display that shows all user-designated parameter and state variables. For an example of what this looks like, view the UI for the <a href="https://github.com/rtxi/neuron/">neuron module</a>. To do things like add buttons or extra windows, the <code>customizeGUI</code> function is needed.</p></div><div><a data-toggle="collapse" data-target="#header4"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">   <span class="nl">protected:</span>

      <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">DefaultGUIModel</span><span class="o">::</span><span class="n">update_flags_t</span><span class="p">);</span>

   <span class="k">private</span><span class="o">:</span>

      <span class="kt">double</span> <span class="n">some_parameter</span><span class="p">;</span>
      <span class="kt">double</span> <span class="n">some_state</span><span class="p">;</span>
      <span class="kt">double</span> <span class="n">period</span><span class="p">;</span>

      <span class="kt">void</span> <span class="n">initParameters</span><span class="p">();</span></code></pre></figure></a></div><div class="collapse" id="header4"><p>The <code>update</code> function is used to inject custom code around events triggered within the UI. Definitions of what those states are are found in the source file.</p><p>The <code>initParameters</code> function can also be used to initialize parameters. It is called within the module constructor, which is defined in the source files, too.</p></div><div><a data-toggle="collapse" data-target="#header5"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">   <span class="k">private</span> <span class="n">slots</span><span class="o">:</span>
   <span class="c1">// these are custom functions that can also be connected
</span>   <span class="c1">// to events through the Qt API. they must be implemented
</span>   <span class="c1">// in plugin_template.cpp
</span>
      <span class="kt">void</span> <span class="n">aBttn_event</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
      <span class="kt">void</span> <span class="n">bBttn_event</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="p">};</span></code></pre></figure></a></div><div class="collapse" id="header5"><p><code>private slots:</code> are part of the Qt signals and slots API. They are used to connect some state change in a widget, like pushing a button, to some function. For the <code>PluginTemplate</code>, the slots are used to connect the buttons in the UI to the function definitions of <code>aBttn_event</code> and <code>bBttn_event</code>.</p></div><h4 class="page-header">plugin-template.cpp</h4><div><a data-toggle="collapse" data-target="#source1"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cm">/*
 * This is a template implementation file for a user module derived from
 * DefaultGUIModel with a custom GUI.
 */</span>

<span class="cp">#include &lt;plugin-template.h&gt;
#include &lt;main_window.h&gt;
#include &lt;iostream&gt;</span></code></pre></figure></a></div><div class="collapse" id="source1"><p><code>main_window.h</code> is the header file for the main RTXI application window. It's included here so that the module being created can reference the main window as it's parent. That way, the modules will be displayed within the main window. <code>iostream</code> is for writing things to standard output (i.e. the terminal). In the base code, <code>PluginTemplate</code> doesn't write to output, but you can change that if you'd like. Just remember to avoid writes within the <code>execute</code> function, or you'll crash RTXI.</p></div><div><a data-toggle="collapse" data-target="#source2"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">extern</span> <span class="s">"C"</span> <span class="n">Plugin</span><span class="o">::</span><span class="n">Object</span> <span class="o">*</span><span class="n">createRTXIPlugin</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
   <span class="k">return</span> <span class="k">new</span> <span class="n">PluginTemplate</span><span class="p">();</span>
<span class="p">}</span></code></pre></figure></a></div><div class="collapse" id="source2"><p><code>extern "C"</code> is implemented to prevent name-mangling by the C++ compiler. Normally, C++ uses name-mangling to allow many different definitions of an object with a same name. In other words, object names can be overloaded. Because this is a module, RTXI needs to load the dynamically-allocated module in memory. If the name gets mangled by the C++ compiler, then RTXI has to look for whatever that name was mangled into; however, RTXI cannot do this, meaning that it will be unable to find any name-mangled module. Therefore, we use <code>extern "C"</code>.</p></div><div><a data-toggle="collapse" data-target="#source3"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">static</span> <span class="n">DefaultGUIModel</span><span class="o">::</span><span class="n">variable_t</span> <span class="n">vars</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
   <span class="p">{</span> <span class="s">"GUI label"</span><span class="p">,</span> <span class="s">"Tooltip description"</span><span class="p">,</span> <span class="n">DefaultGUIModel</span><span class="o">::</span><span class="n">PARAMETER</span>
      <span class="o">|</span> <span class="n">DefaultGUIModel</span><span class="o">::</span><span class="n">DOUBLE</span><span class="p">,</span> <span class="p">},</span>
   <span class="p">{</span> <span class="s">"A State"</span><span class="p">,</span> <span class="s">"Tooltip description"</span><span class="p">,</span> <span class="n">DefaultGUIModel</span><span class="o">::</span><span class="n">STATE</span><span class="p">,</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="n">num_vars</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vars</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DefaultGUIModel</span><span class="o">::</span><span class="n">variable_t</span><span class="p">);</span></code></pre></figure></a></div><div class="collapse" id="source3"><p><code>vars[]</code> is an array that contains instances of the <code>variable_t</code> struct, which is defined in <code>DefaultGUIModel</code>. <code>vars[]</code> is used to pass variables to be the <code>DefaultGUIModel</code> constructor. In the base code for this module, there are two variables, <code>GUI label</code> and <code>A State</code>. Each is separately instantiated within <code>vars[]</code>.</p><p>Each element added to <code>vars[]</code> must have at least three components:</p><dl class="dl-horizontal"><dt>string name</dt><dd>the label for the variable made visible in the GUI</dd><dt>string description</dt><dd>tooltip description displayed when the mouse hovers over the label</dd><dt>flags_t flags</dt><dd>the type for the variable, such as <code>STATE</code>, <code>PARAMETER</code>, <code>INPUT</code>, <code>OUTPUT</code>, or <code>COMMENT</code></dd></dl><p>Note that the strings are of type <code>std::string</code>. Qt has its own string implementation, called <code>QString</code>, so take care to not confuse ordinary C strings with them. Also note that <code>flags_t</code> type is defined in <code>io.h</code>. It is an unsigned long int used within RTXI for input and output processing. Simply put, it is a method RTXI uses to define different types for variables that represent different components to be displayed by the GUI and/or processed by the module.</p><p>Additional information about the type parameter can be added by using the <code>|</code> operator. Note that <code>|</code> here represents a bitwise OR operator. What this additional information does is apply an RTXI-specific data type to a variable within <code>vars[]</code>. In the base code for GUI label, the variable is of type <code>PARAMETER</code>, and <code>| DOUBLE</code> means that the variable is a parameter of type <code>DOUBLE</code>, a data type that stores 8-byte floating point numbers. If we wanted integers, we would use <code>INTEGER</code> instead of <code>DOUBLE</code>. Again, note that <code>PARAMETER</code>, <code>INTEGER</code>, etc. are not native C++ types but instead are RTXI-specific.</p><p>The GUI is made by iterating through all the elements of <code>vars[]</code> and appending a widget to the GUI window for each one. Because the vars array does not have a native count of the number of elements within, we create a variable called <code>num_vars</code> that stores that number.</p><p>The size of the elements within are contingent on their types, so the <code>variable_t</code> type is used within the <code>sizeof()</code> command. Because the count of variables cannot change after the module is compiled and run within RTXI, <code>num_vars</code> is declared as static, meaning that it cannot be changed from within the program after it is initialized.</p></div><div><a data-toggle="collapse" data-target="#source4"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">PluginTemplate</span><span class="o">::</span><span class="n">PluginTemplate</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">:</span> <span class="n">DefaultGUIModel</span><span class="p">(</span><span class="s">"PluginTemplate with Custom GUI"</span><span class="p">,</span> <span class="o">::</span><span class="n">vars</span><span class="p">,</span> <span class="o">::</span><span class="n">num_vars</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">setWhatsThis</span><span class="p">(</span><span class="s">"&lt;p&gt;&lt;b&gt;PluginTemplate:&lt;/b&gt;&lt;br&gt;QWhatsThis description.&lt;/p&gt;"</span><span class="p">);</span>
   <span class="n">DefaultGUIModel</span><span class="o">::</span><span class="n">createGUI</span><span class="p">(</span><span class="n">vars</span><span class="p">,</span> <span class="n">num_vars</span><span class="p">);</span> <span class="c1">// this is required to create the GUI
</span>   <span class="n">customizeGUI</span><span class="p">();</span>
   <span class="n">initParameters</span><span class="p">();</span>
   <span class="n">update</span><span class="p">(</span> <span class="n">INIT</span> <span class="p">);</span> <span class="c1">// this is optional, you may place initialization code directly into the construct    or
</span>   <span class="n">refresh</span><span class="p">();</span> <span class="c1">// this is required to update the GUI with parameter and state values
</span>   <span class="n">QTimer</span><span class="o">::</span><span class="n">singleShot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">resizeMe</span><span class="p">()));</span>
<span class="p">}</span>

<span class="n">PluginTemplate</span><span class="o">::~</span><span class="n">PluginTemplate</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span></code></pre></figure></a></div><div class="collapse" id="source4"><p><code>PluginTemplate</code> inherits from <code>DefaultGUIModel</code>., so when its constructor is called, so is that of <code>DefaultGUIModel</code>. <code>DefaultGUIModel</code>'s constructor takes three arguments:</p><ol><li>A string representing the name of the module displayed in its titlebar</li><li>The <code>vars[]</code> array</li><li><code>num_vars</code></li></ol><p>The functions called within the constructor are defined later. The <code>QTimer::singleShot</code> call is so make the UI resize properly if <code>customizeGUI</code> is used to edit the default UI.</p></div><div><a data-toggle="collapse" data-target="#source4-5"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">PluginTemplate</span><span class="o">::</span><span class="n">initParameters</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">some_parameter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">some_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">return</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure></a></div><div class="collapse" id="source4-5"><p>The <code>initParameters</code> function is an optional function you can use to initialize variables. Of course, you can define all this in the module constructor. Note that here, the variablles that are initialized are those that are ultimately linked to a <code>PARAMATER</code> and <code>STATE</code>. Therefore, <code>initParameters</code> should be called before <code>update(INIT)</code>.</p></div><div><a data-toggle="collapse" data-target="#source5"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">PluginTemplate</span><span class="o">::</span><span class="n">execute</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure></a></div><div class="collapse" id="source5"><p>This is the execute loop. All the code in here is run using the real-time thread. Each cycle, RTXI takes all the code run in all definitions of various modules' <code>execute</code>. If you are outputting a signal in real-time, the code goes here. If you are reading in voltages to compute membrane resistance, etc., the code for that goes here. What <b>does not</b> go here is Qt code.</p><p><b>Do not</b> operate on a Qt widget within the execute loop. Doing so forces the system to alter what is being displayed on the screen, which involves calls to the X server, video driver, the standard Linux kernel (if modesetting is active), etc., and all that has to be completed within the real-time period. Needless to say, that's an easy way to get knocked out of real-time. Don't run UI things within the execute loop.</p><p>Within the plugin template, nothing is running within the execute loop. You can add whatever code you need here, and it will run whenever the module is unpaused.</p></div><div><a data-toggle="collapse" data-target="#source6"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">PluginTemplate</span><span class="o">::</span><span class="n">update</span><span class="p">(</span><span class="n">DefaultGUIModel</span><span class="o">::</span><span class="n">update_flags_t</span> <span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">switch</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="n">INIT</span><span class="p">:</span>
         <span class="n">period</span> <span class="o">=</span> <span class="n">RT</span><span class="o">::</span><span class="n">System</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getPeriod</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1e-6</span><span class="p">;</span> <span class="c1">// ms
</span>         <span class="n">setParameter</span><span class="p">(</span><span class="s">"GUI label"</span><span class="p">,</span> <span class="n">some_parameter</span><span class="p">);</span>
         <span class="n">setState</span><span class="p">(</span><span class="s">"A State"</span><span class="p">,</span> <span class="n">some_state</span><span class="p">);</span>
         <span class="k">break</span><span class="p">;</span>

      <span class="k">case</span> <span class="n">MODIFY</span><span class="p">:</span>
         <span class="n">some_parameter</span> <span class="o">=</span> <span class="n">getParameter</span><span class="p">(</span><span class="s">"GUI label"</span><span class="p">).</span><span class="n">toDouble</span><span class="p">();</span>
         <span class="k">break</span><span class="p">;</span>

      <span class="k">case</span> <span class="n">UNPAUSE</span><span class="p">:</span>
         <span class="k">break</span><span class="p">;</span>

      <span class="k">case</span> <span class="n">PAUSE</span><span class="p">:</span>
         <span class="k">break</span><span class="p">;</span>

      <span class="k">case</span> <span class="n">PERIOD</span><span class="p">:</span>
         <span class="n">period</span> <span class="o">=</span> <span class="n">RT</span><span class="o">::</span><span class="n">System</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getPeriod</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1e-6</span><span class="p">;</span> <span class="c1">// ms
</span>         <span class="k">break</span><span class="p">;</span>

      <span class="k">default</span><span class="o">:</span>
         <span class="k">break</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span></code></pre></figure></a></div><div class="collapse" id="source6"><p>This is the <code>update</code> function. It injects code into events that allow modules to adjust to changes in the RTXI application. Whenever events, like pushing the pause button or changing the real-time period via the Control Panel, are triggered, their code includes calls to the <code>update</code> function and pass to it flags relating to the case in which the function is being called. The cases are:</p><dl class="dl-horizontal"><dt><code>INIT</code></dt><dd><p>Called whenever the module is being initialized, particularly in the constructor. Things to initialize, for instance, are the value for RTXI's real-time period and other variables derived from it. It is here, too, that you should set <code>PARAMETER</code>, <code>COMMENT</code>, and <code>STATE</code> variables. This is done via calls, respectively, to <code>setParameter</code> <code>setComment</code> <code>setState</code>.</p></dd><dt><code>MODIFY</code></dt><dd><p><code>MODIFY</code> is used whenever the Modify button is pressed within the UI. It can be called elsewhere, too. It's the module designer's choice. In the base code for the plugin template, the <code>GUI label</code> parameter is displayed in the GUI as a label that says "GUI label" followed by a text box containing a floating point value that the user can modify by typing some new value in the text box. When a value is typed in and the user clicks the "Modify" button in the GUI, the <code>MODIFY</code> flag is passed to <code>update</code>, and the changed value is extracted, converted to <code>std::double</code>, and stored in <code>some_parameter</code>.</p></dd><dt><code>UNPAUSE</code></dt><dd><p>Called when the module is unpaused.</p></dd><dt><code>PAUSE</code></dt><dd><p>Called when the module is paused.</p></dd><dt><code>PERIOD</code></dt><dd><p>Called whenever the real-time period is changed by the Control Panel module.</p></dd><dt><code>EXIT</code></dt><dd><p>Called whenever the module is closed.</p></dd></dl><p>Look though our <a href="/doxygen">doxygen pages</a> to find out how to properly use built-in RTXI functions.</p></div><div><a data-toggle="collapse" data-target="#source7"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">PluginTemplate</span><span class="o">::</span><span class="n">customizeGUI</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">QGridLayout</span> <span class="o">*</span><span class="n">customlayout</span> <span class="o">=</span> <span class="n">DefaultGUIModel</span><span class="o">::</span><span class="n">getLayout</span><span class="p">();</span>

   <span class="n">QGroupBox</span> <span class="o">*</span><span class="n">button_group</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QGroupBox</span><span class="p">;</span>

   <span class="n">QPushButton</span> <span class="o">*</span><span class="n">abutton</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Button A"</span><span class="p">);</span>
   <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bbutton</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Button B"</span><span class="p">);</span>
   <span class="n">QHBoxLayout</span> <span class="o">*</span><span class="n">button_layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QHBoxLayout</span><span class="p">;</span>
   <span class="n">button_group</span><span class="o">-&gt;</span><span class="n">setLayout</span><span class="p">(</span><span class="n">button_layout</span><span class="p">);</span>
   <span class="n">button_layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">abutton</span><span class="p">);</span>
   <span class="n">button_layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bbutton</span><span class="p">);</span>
   <span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">abutton</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">clicked</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">aBttn_event</span><span class="p">()));</span>
   <span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">bbutton</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">clicked</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">bBttn_event</span><span class="p">()));</span>

   <span class="n">customlayout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">button_group</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
   <span class="n">setLayout</span><span class="p">(</span><span class="n">customlayout</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure></a></div><div class="collapse" id="source7"><p>The <code>customizeGUI</code> function is designed for users to customize the default UI output created by the <code>DefaultGUIModel</code> class. The initial module is created by the <code>createGUI</code> function called above in the constructor. Broadly speaking, this function takes the output of <code>createGUI</code> and adds custom elements to it. To use this function, you will need to know what the Qt classes are and how to use them properly. Documentation is available on the Qt website. (<a href="http://doc.qt.io/qt-5.5/">http://doc.qt.io/qt-5.5/</a>)</p><p>To customize the module UI, it first needs to be grabbed and stored in a variable, which is accomplished in the first line of the function. <code>DefaultGUIModel::getLayout()</code> returns an object of type <code>QGridLayout</code>. This essentially is a widget that allows Qt objects to be aligned according to a grid layout. The layout of <code>DefaultGUIModel</code> is as follows:</p><img class="img-responsive" src="/assets/img/tutorials/default_gui_layout.svg" style="max-height:450px"><br><p>By default, the main UI is displayed within the grid at coordinates (1,0) and the utility box with the pause, modify, and exit buttons at coordinates (10,0). All other positions on the grid are empty.</p><p>Note that the size of grid coordinates are arbitrary. They are as big as the widgets that are stuck within them. They're equally-sized in the diagram just for clarity. Look through Qt's documentation for instructions on how to set widgets at specific positions in the grid layout.</p><p>Also, note that coordinates that are empty are not rendered, so there is no big gap between the Main UI and the Button UI because there is nothing put in spots (2,0) to (9,0). Keep in mind, though, that the <code>QGridLayout</code> will not allow objects in diffrent rows to overlap. For example, if you added an object to (1,5), the UI in (0,1) would render, followed by a gap the size of the widget in (1,5), and then the buttons in (0,10). The object in (1,5) would be shown in column 1.</p><p>The rest of the code in <code>customizeGUI</code> creates two buttons and sticks them into coordinate (0,0). The buttons are then connected to functions using Qt's signals and slots API. When a button is pressed, it emits a signal that it has been pressed, and the <code>connect</code> connects that signal to a function. The effect is then to call the function whenever the button is pressed.</p><p>When all the modifications are complete, they need to be added to the module layout that was grabbed by <code>DefaultGUIModel::getLayout()</code>. This is done using the <code>setLayout</code> command.</p></div><div><a data-toggle="collapse" data-target="#source8"><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">// functions designated as Qt slots are implemented as regular C++ functions
</span><span class="kt">void</span> <span class="n">PluginTemplate</span><span class="o">::</span><span class="n">aBttn_event</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">void</span> <span class="n">PluginTemplate</span><span class="o">::</span><span class="n">bBttn_event</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span></code></pre></figure></a></div><div class="collapse" id="source8"><p>These functions are called whenever their respective buttons are pressed. By default, the functions don't do anything. It is up to users to add what they want.</p></div></div><div id="hdf" style="padding-top:30px; margin-top:-30px"><h3 class="page-header">HDF5 Data Files</h3><p>The HDF5 file format is a portable and extensible binary data format designed for complex data. It supports an unlimited variety of datatypes and flexible and efficient methods for data retrieval and storage. HDF5 features a hierarchical structure that allows access to chunks of data without loading the entire file into memory. The Data Recorder module outputs to an HDF5 file.</p><p>At the topmost level, an RTXI HDF5 file is divided into separate <i>Trial</i> groups, each of which contains the system settings and module parameter values that existed at the time that data was recorded. The Data Recorder only saves parameter values for modules from which it is recording a signal. A new <i>Trial</i> is created whenever the Data Recorder is used to start recording. For example, if you stop and start recording multiple times in a single session, RTXI automatically increments the trial number each time. If you choose to save data to a file that already exists, RTXI will prompt you with a choice to overwrite the file or append new data to the file. Appending data to a file also creates a new <i>Trial</i>. Thus, it is possible to have trials within the same file that contain different parameter settings and even data downsampling rates.</p><p>Parameter values from user modules are saved in the <i>Parameters</i> group within each <i>Trial</i>. The name of each parameter includes the module instance ID number within RTXI, the name of the module, and the name of the parameter itself. If the value of the parameter changes during recording, all the values are saved with a corresponding index value that is the timestamp in nanoseconds from the start of the recording. This feature is only available for user modules that are based on the <code>DefaultGUIModel</code> class. Note that certain naming conventions for parameters also apply in order for them to be captured to HDF5.</p><p>Real-time signals in RTXI are streamed to the <i>Synchronous Data</i> structure within each <i>Trial</i>. This group contains separate fields with the name of each synchronous channel and a single dataset that contains all the synchronous data. The order of the channel names corresponds with the columns in the dataset.</p><figure class="figure"><img src="/assets/img/manual/axoclamptutorial5.png" class="figure-img img-fluid"><figcaption class="figure-caption">RTXI uses a hierarchical HDF5 data structure organized into <i>Trials</i>. Each <i>Trial</i> contains the system settings and parameter values for that trial. This screenshot is taken using HDFView, a free software for browsing HDF5 files.</figcaption></figure><p>There are various software available for working with HDF5 files. To simply browse the file structure, you can use the free HDFView application:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>sudo apt-get install hdfview</code></pre></figure><p>HDFView provides some limited editing capabilities. For trials where only a single channel is saved, you can also preview a plot of the data. To extract the data for analysis and for complete editing capabilities, APIs are available for MATLAB, GNU Octave, Igor Pro, Mathematica, Python, Scilab, and other software.</p><p>RTXI also includes a simple MATLAB GUI for quickly viewing the data within a single trial. The MATLAB code is available in the <a href="https://github.com/rtxi/analysis-tools">Analysis Tools repository</a>. A sample m-file called <code>example.m</code> provides examples of how to extract data to the MATLAB workspace, use the GUI browser, and add new datasets to your file. It is also possible to embed binary formats, such as images, within a trial.</p><p>The GUI browser allows you to view the parameters, channels, and plots of the data within a single trial with the <code>rtxibrowse()</code> function. This generates a MATLAB figure window with the filename and trial number in the menu bar. To browse trials within the same HDF5 file, use the buttons in the lower left corner. The left panel lists the initial values for all the module parameters. If a parameter value has changed during the recording, this is denoted with an asterisk. The new values and their timestamps can be viewed by using the <code>getTrial()</code> function, which returns a MATLAB structure containing all the information within a trial. The GUI plots two channels from the same trial. Use the middle upper and and lower panels to select the data that is plotted in the right upper and lower panels. Double-clicking on a channel name in the middle panel will create a new figure window with that data plotted. This allows you to continue browsing through other trials in the main GUI window while keeping this additional plot available.</p><figure class="figure"><img src="/assets/img/manual/axoclamptutorial6.png" class="figure-img img-fluid"><figcaption class="figure-caption">The MATLAB GUI browser allows you to view the parameters, channels, and plots of the data within a single trial.</figcaption></figure></div></div></div></div></div></body><style>html {
  position: relative;
  min-height: 100%;
}
body {
  margin-bottom: 60px;
  margin-top: 10px;
}
.footer {
  position: absolute;
  top: 100%;
  bottom: auto;
  width: 100%;
  height: -60px;
  background-color: #c1c1c1;
}</style><div class="footer"><div class="container"><div class="row"><div class="col-sm-6 text-center" style="margin-top:50px; margin-bottom:10px"><a href="http://www.nih.gov/"><img class="img-responsive" alt="NIH grant 2R01EB016407-09" src="/assets/img/nih-logo-trans.svg"></a></div><div class="col-sm-6 text-center" style="margin-top:55px"><a href="https://github.com/rtxi"><img class="img-responsive" alt="RTXI on GitHub" src="/assets/img/github-logo.svg"></a></div></div><div style="margin-bottom:40px"></div></div></div><script src="/assets/js/default.min.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-5550734-5', 'auto');
		ga('send', 'pageview');</script><script>var navHeight = $('.navbar').outerHeight(true) + 10; var topblockHeight = $('#topblock').outerHeight(true);
/* activate sidebar */ $('#sidebar').affix({ offset: { top: topblockHeight } });
/* activate scrollspy menu */ $('body').scrollspy({ target: '#leftCol', offset: navHeight });
/* enable smooth scrolling */ $('#leftCol a').on('click', function(event) { event.preventDefault(); var hash = this.hash;
$('html, body').animate({ scrollTop: $(hash).offset().top }, 200, function() { window.location.hash = hash; }); });</script></html>