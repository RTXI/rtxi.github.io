<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Understanding the Plugin Template</title><link href="/assets/css/bootstrap.min.css" rel="stylesheet"><link href="/assets/css/pygments.css" rel="stylesheet"><link href="/assets/css/octicons.min.css" rel="stylesheet"><link href="/assets/css/font-awesome.min.css" rel="stylesheet"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="icon" href="/favicon.ico"></head><style>h1, h2, h3, h4, h5, h6 {
      padding-bottom: 9px;
      margin: 40px 0 20px;
      border-bottom: 1px solid #eee;
      font-weight: normal;
   }
   img {
      margin-left: auto;
      margin-right: auto;
      display: block;
      max-width: 100%;
      height: auto;
   }</style><style>body {
   padding-top:50px;
   padding-bottom:30px;
}</style><nav class="navbar navbar-inverse navbar-fixed-top" role="navigation"><div class="container"><div class="navbar-header"><button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" rel="home" href="/"><b>RTXI</b></a></div><div class="row"><div id="navbar" class="navbar-collapse collapse navbar-right" style="text-align:center"><ul class="nav navbar-nav"><li><a href="/install/">Install</a></li><li><a href="/modules/">Modules</a></li><li><a href="/papers/">Papers</a></li><li class="active"><a href="/docs/">Docs</a></li><li><a href="/stats/">Stats</a></li><li><a href="/community/">Community</a></li><li><a href="/contact/">Contact</a></li><li><a href="/feed.xml"><i class="fa fa-rss fa-inverse"></i></a></li></ul></div></div></div></nav><body style="padding-top:30px"><div class="container"><h3 class="page-header">Understanding the Plugin Template</h3><p>This is an explanation for the code found in the <a href="/modules/plugin-template/">plugin template module</a> and a brief introduction to the DefaultGUI framework it abstracts. The plugin template is a starting point for building modules from scratch, but you can fork <a href="/modules/">any other module</a>, too. Below is the contents of <code>plugin-template.cpp</code> and <code>plugin-template.h</code>. Click on a function to see an explanation of what it does and how it relates to RTXIâ€™s framework. If anything is unclear, <a href="https://github.com/rtxi/rtxi.github.io/issues">let us know</a>.</p><p>This tutorial will assume the reader has a basic understanding of C++, such as how to include libraries and source files, classes, inheritance, etc. For a quick run-down of C++ for people already familiar with programming, try <a href="http://www.cplusplus.com/doc/tutorial/">here</a>.</p><h4 id="plugin-templateh">plugin-template.h</h4><div><a data-toggle="collapse" data-target="#header1"><div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cm">/*</span>
<span class="cm">* This is a template header file for a user modules derived from</span>
<span class="cm">* DefaultGUIModel with a custom GUI.</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;QMdiArea&gt;</span>
<span class="cp">#include &lt;default_gui_model.h&gt;</span></code></pre></div></a></div><div class="collapse" id="header1"><p><code>QMdiArea</code> refers to a Qt4 class that manages MDI windows, windows subclassed under the main application window. This provides a method for Qt to take care of allocating, freeing memory for widgets when they are opened or closed within the RTXI application.</p><p><code>default_gui_model.h</code> is the header for the <code>DefaultGUIModel</code> class that <code>PluginTemplate</code> abstracts from. The file itself is stored in <code>include/default_gui_model.h</code> in the <a href="https://github.com/rtxi/rtxi">RTXI repository</a>. <code>DefaultGUI</code> is on its own a mechanism by which users can create their own plugins. <code>PluginTemplate</code> simply obscures some of the more arcane functions and provides a more simplified programming experience.</p></div><div><a data-toggle="collapse" data-target="#header2"><div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">PluginTemplate</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DefaultGUIModel</span> <span class="p">{</span>

   <span class="n">Q_OBJECT</span></code></pre></div></a></div><div class="collapse" id="header2"><p>The <code>PluginTemplate</code> abstracts from <code>DefaultGUIModel</code> to fit within RTXI's framework. To fit within that of Qt4, it uses the <code>Q_OBJECT</code> macro, used to insert code that implements the signals and slots methods used for communication between different <code>QObjects</code>. <code>QObjects</code> are a basic class from which other Qt classes are derived. Basically, the <code>Q_OBJECT</code> macro indicates that the class is to be treated as a <code>QObject</code>.</p></div><div><a data-toggle="collapse" data-target="#header3"><div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">public</span><span class="o">:</span>

      <span class="n">PluginTemplate</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
      <span class="k">virtual</span> <span class="o">~</span><span class="n">PluginTemplate</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

      <span class="kt">void</span> <span class="nf">execute</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
      <span class="kt">void</span> <span class="nf">customizeGUI</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span></code></pre></div></a></div><div class="collapse" id="header3"><p>The functions of the constructor and destructor should be obvious.</p><p>The <code>execute</code> function is used to run code within the real-time loop. In other words, whatever get's put in here will be run in real-time. Whatever is run here should be as time and memory-efficient as possible. After all, to run RTXI at high frequencies (40-50 kHz) the code must take microseconds to execute.</p><p>The <code>customizeGUI</code> function is used to add and edit UI elements on the display. By default, <code>DefaultGUI</code> creates widget display that shows all user-designated parameter and state variables. For an example of what this looks like, view the UI for the <a href="https://github.com/rtxi/neuron/">neuron module</a>. To do things like add buttons or extra windows, the <code>customizeGUI</code> function is needed.</p></div><div><a data-toggle="collapse" data-target="#header4"><div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">protected</span><span class="o">:</span>

      <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">DefaultGUIModel</span><span class="o">::</span><span class="kt">update_flags_t</span><span class="p">);</span>

   <span class="k">private</span><span class="o">:</span>

      <span class="kt">double</span> <span class="n">some_parameter</span><span class="p">;</span>
      <span class="kt">double</span> <span class="n">some_state</span><span class="p">;</span>
      <span class="kt">double</span> <span class="n">period</span><span class="p">;</span></code></pre></div></a></div><div class="collapse" id="header4"><p>The <code>update</code> function is used to inject custom code around events triggered within the UI. Definitions of what those states are are found in the source file.</p></div><div><a data-toggle="collapse" data-target="#header5"><div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">private</span> <span class="nl">slots</span><span class="p">:</span>
   <span class="c1">// these are custom functions that can also be connected</span>
   <span class="c1">// to events through the Qt API. they must be implemented</span>
   <span class="c1">// in plugin_template.cpp</span>

      <span class="kt">void</span> <span class="n">aBttn_event</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
      <span class="kt">void</span> <span class="nf">bBttn_event</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="p">};</span></code></pre></div></a></div><div class="collapse" id="header5"><p><code>private slots:</code> are part of the Qt signals and slots API. They are used to connect some state change in a widget, like pushing a button, to some function. For the <code>PluginTemplate</code>, the slots are used to connect the buttons in the UI to the function definitions of <code>aBttn_event</code> and <code>bBttn_event</code>.</p></div><h4 id="plugin-templatecpp">plugin-template.cpp</h4><div><a data-toggle="collapse" data-target="#source1"><div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cm">/*</span>
<span class="cm">* This is a template implementation file for a user module derived from</span>
<span class="cm">* DefaultGUIModel with a custom GUI.</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;plugin-template.h&gt;</span>
<span class="cp">#include &lt;main_window.h&gt;</span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;QtGui&gt;</span></code></pre></div></a></div><div class="collapse" id="source1"><p><code>QtGui</code> is used to include all the Qt-related UI elements, like buttons, widgets, text boxes, etc. <code>main_window.h</code> is the header file for the main RTXI application window. It's included here so that the module being created can reference the main window as it's parent. In other words, the modules will be displayed within the main window, and if the main window is closed, so are the modules. <code>iostream</code> is for writing things to standard output (i.e. the terminal). In the base code, <code>PluginTemplate</code> doesn't write to output, but you can change that if you'd like. Just remember to avoid writes within the <code>execute</code> function, or you'll crash RTXI or, even worse, crash the desktop.</p></div><div><a data-toggle="collapse" data-target="#source2"><div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="n">Plugin</span><span class="o">::</span><span class="n">Object</span> <span class="o">*</span><span class="n">createRTXIPlugin</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
   <span class="k">return</span> <span class="k">new</span> <span class="n">PluginTemplate</span><span class="p">();</span>
<span class="p">}</span></code></pre></div></a></div><div class="collapse" id="source2"><p><code>extern "C"</code> is implemented to prevent name-mangling by the C++ compiler. Normally, C++ uses name-mangling to allow many different definitions of an object with a same name. In other words, object names can be overloaded. Because this is a module, RTXI needs to load the dynamically-allocated module in memory. If the name gets mangled by the C++ compiler, then RTXI has to look for whatever that name was mangled into; however, RTXI cannot do this, meaning that it will be unable to find any name-mangled module. Therefore, we use <code>extern "C"</code>.</p></div><div><a data-toggle="collapse" data-target="#source3"><div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">static</span> <span class="n">DefaultGUIModel</span><span class="o">::</span><span class="kt">variable_t</span> <span class="n">vars</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
   <span class="p">{</span> <span class="s">&quot;GUI label&quot;</span><span class="p">,</span> <span class="s">&quot;Tooltip description&quot;</span><span class="p">,</span> <span class="n">DefaultGUIModel</span><span class="o">::</span><span class="n">PARAMETER</span>
      <span class="o">|</span> <span class="n">DefaultGUIModel</span><span class="o">::</span><span class="n">DOUBLE</span><span class="p">,</span> <span class="p">},</span>
   <span class="p">{</span> <span class="s">&quot;A State&quot;</span><span class="p">,</span> <span class="s">&quot;Tooltip description&quot;</span><span class="p">,</span> <span class="n">DefaultGUIModel</span><span class="o">::</span><span class="n">STATE</span><span class="p">,</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="n">num_vars</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vars</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DefaultGUIModel</span><span class="o">::</span><span class="kt">variable_t</span><span class="p">);</span></code></pre></div></a></div><div class="collapse" id="source3"><p><code>vars[]</code> is an array that contains instances of the <code>variable_t</code> struct, which is defined in <code>DefaultGUIModel</code>. <code>vars[]</code> is used to pass variables to be the <code>DefaultGUIModel</code> constructor. In the base code for this module, there are two variables, <code>GUI label</code> and <code>A State</code>. Each is separately instantiated within <code>vars[]</code>.</p><p>Each element added to <code>vars[]</code> must have at least three components:</p><dl class="dl-horizontal"><dt>string name</dt><dd>the label for the variable made visible in the GUI</dd><dt>string description</dt><dd>tooltip description displayed when the mouse hovers over the label</dd><dt>flags_t flags</dt><dd>the type for the variable, such as <code>STATE</code>, <code>PARAMETER</code>, <code>INPUT</code>, <code>OUTPUT</code>, or <code>COMMENT</code></dd></dl><p>Note that the strings are of type <code>std::string</code>. Qt has its own string implementation, called <code>QString</code>, so take care to not confuse ordinary C strings with them. Also note that <code>flags_t</code> type is defined in <code>io.h</code>. It is an unsigned long int used within RTXI for input and output processing. Simply put, it is a method RTXI uses to define different types for variables that represent different components to be displayed by the GUI and/or processed by the module.</p><p>Additional information about the type parameter can be added by using the <code>|</code> operator. Note that <code>|</code> here represents a bitwise OR operator. What this additional information does is apply an RTXI-specific data type to a variable within <code>vars[]</code>. In the base code for GUI label, the variable is of type <code>PARAMETER</code>, and <code>| DOUBLE</code> means that the variable is a parameter of type <code>DOUBLE</code>, a data type that stores 8-byte floating point numbers. If we wanted integers, we would use <code>INTEGER</code> instead of <code>DOUBLE</code>. Again, note that <code>PARAMETER</code>, <code>INTEGER</code>, etc. are not native C++ types but instead are RTXI-specific.</p><p>The GUI is made by iterating through all the elements of <code>vars[]</code> and appending a widget to the GUI window for each one. Because the vars array does not have a native count of the number of elements within, we create a variable called <code>num_vars</code> that stores that number.</p><p>The size of the elements within are contingent on their types, so the <code>variable_t</code> type is used within the <code>sizeof()</code> command. Because the count of variables cannot change after the module is compiled and run within RTXI, <code>num_vars</code> is declared as static, meaning that it cannot be changed from within the program after it is initialized.</p></div><div><a data-toggle="collapse" data-target="#source4"><div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">PluginTemplate</span><span class="o">::</span><span class="n">PluginTemplate</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">:</span> <span class="n">DefaultGUIModel</span><span class="p">(</span><span class="s">&quot;PluginTemplate with Custom GUI&quot;</span><span class="p">,</span> <span class="o">::</span><span class="n">vars</span><span class="p">,</span> <span class="o">::</span><span class="n">nu</span>    <span class="n">m_vars</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">setWhatsThis</span><span class="p">(</span><span class="s">&quot;&lt;p&gt;&lt;b&gt;PluginTemplate:&lt;/b&gt;&lt;br&gt;QWhatsThis description.&lt;/p&gt;&quot;</span><span class="p">);</span>
   <span class="n">DefaultGUIModel</span><span class="o">::</span><span class="n">createGUI</span><span class="p">(</span><span class="n">vars</span><span class="p">,</span> <span class="n">num_vars</span><span class="p">);</span> <span class="c1">// this is required to create the GUI</span>
   <span class="n">customizeGUI</span><span class="p">();</span>
   <span class="n">update</span><span class="p">(</span> <span class="n">INIT</span> <span class="p">);</span> <span class="c1">// this is optional, you may place initialization code directly into the construct    or</span>
   <span class="n">refresh</span><span class="p">();</span> <span class="c1">// this is required to update the GUI with parameter and state values</span>
   <span class="n">QTimer</span><span class="o">::</span><span class="n">singleShot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">resizeMe</span><span class="p">()));</span>
<span class="p">}</span>

<span class="n">PluginTemplate</span><span class="o">::~</span><span class="n">PluginTemplate</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span></code></pre></div></a></div><div class="collapse" id="source4"><p><code>PluginTemplate</code> inherits from <code>DefaultGUIModel</code>., so when its constructor is called, so is that of <code>DefaultGUIModel</code>. <code>DefaultGUIModel</code>'s constructor takes three arguments:</p><ol><li>A string representing the name of the module displayed in its titlebar</li><li>The <code>vars[]</code> array</li><li><code>num_vars</code></li></ol><p>The functions called within the constructor are defined later. The <code>QTimer::singleShot</code> call is so make the UI resize properly if the <code>customizeGUI</code> adds/removes UI elements.</p></div><div><a data-toggle="collapse" data-target="#source5"><div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">PluginTemplate</span><span class="o">::</span><span class="n">execute</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span><span class="p">;</span>
<span class="p">}</span></code></pre></div></a></div><div class="collapse" id="source5"><p>This is the execute loop. All the code in here is run using the real-time thread. Each cycle, RTXI takes all the code run in all definitions of various modules' <code>execute</code>. If you are outputting a signal in real-time, the code goes here. If you are reading in voltages to compute membrane resistance, etc., the code for that goes here. What <b>does not</b> go here is Qt code.</p><p><b>Do not</b> operate on a Qt widget within the execute loop. Doing so forces the system to alter what is being displayed on the screen, which involves calls to the X server, video driver, the standard Linux kernel (if modesetting is active), etc., and all that has to be completed within the real-time period. Needless to say, that's an easy way to get knocked out of real-time. Don't run UI things within the execute loop.</p><p>Within the plugin template, nothing is running within the execute loop. You can add whatever code you need here, and it will run whenever the module is unpaused.</p></div><div><a data-toggle="collapse" data-target="#source6"><div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">PluginTemplate</span><span class="o">::</span><span class="n">update</span><span class="p">(</span><span class="n">DefaultGUIModel</span><span class="o">::</span><span class="kt">update_flags_t</span> <span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">switch</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="nl">INIT</span><span class="p">:</span>
         <span class="n">period</span> <span class="o">=</span> <span class="n">RT</span><span class="o">::</span><span class="n">System</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getPeriod</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1e-6</span><span class="p">;</span> <span class="c1">// ms</span>
         <span class="n">setParameter</span><span class="p">(</span><span class="s">&quot;GUI label&quot;</span><span class="p">,</span> <span class="n">some_parameter</span><span class="p">);</span>
         <span class="n">setState</span><span class="p">(</span><span class="s">&quot;A State&quot;</span><span class="p">,</span> <span class="n">some_state</span><span class="p">);</span>
         <span class="k">break</span><span class="p">;</span>

      <span class="k">case</span> <span class="nl">MODIFY</span><span class="p">:</span>
         <span class="n">some_parameter</span> <span class="o">=</span> <span class="n">getParameter</span><span class="p">(</span><span class="s">&quot;GUI label&quot;</span><span class="p">).</span><span class="n">toDouble</span><span class="p">();</span>
         <span class="k">break</span><span class="p">;</span>

      <span class="k">case</span> <span class="nl">UNPAUSE</span><span class="p">:</span>
         <span class="k">break</span><span class="p">;</span>

      <span class="k">case</span> <span class="nl">PAUSE</span><span class="p">:</span>
         <span class="k">break</span><span class="p">;</span>

      <span class="k">case</span> <span class="nl">PERIOD</span><span class="p">:</span>
         <span class="n">period</span> <span class="o">=</span> <span class="n">RT</span><span class="o">::</span><span class="n">System</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getPeriod</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1e-6</span><span class="p">;</span> <span class="c1">// ms</span>
         <span class="k">break</span><span class="p">;</span>

      <span class="k">default</span><span class="o">:</span>
         <span class="k">break</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span></code></pre></div></a></div><div class="collapse" id="source6"><p>This is the <code>update</code> function. It injects code into events that allow modules to adjust to changes in the RTXI application. Whenever events, like pushing the pause button or changing the real-time period via the Control Panel, are triggered, their code includes calls to the <code>update</code> function and pass to it flags relating to the case in which the function is being called. The cases are:</p><dl class="dl-horizontal"><dt><code>INIT</code></dt><dd><p>Called whenever the module is being initialized, particularly in the constructor. Things to initialize, for instance, are the value for RTXI's real-time period and other variables derived from it. It is here, too, that you should set <code>PARAMETER</code>, <code>COMMENT</code>, and <code>STATE</code> variables. This is done via calls, respectively, to <code>setParameter</code> <code>setComment</code> <code>setState</code>.</p></dd><dt><code>MODIFY</code></dt><dd><p><code>MODIFY</code> is used whenever the Modify button is pressed within the UI. It can be called elsewhere, too. It's the module designer's choice. In the base code for the plugin template, the <code>GUI label</code> parameter is displayed in the GUI as a label that says "GUI label" followed by a text box containing a floating point value that the user can modify by typing some new value in the text box. When a value is typed in and the user clicks the "Modify" button in the GUI, the <code>MODIFY</code> flag is passed to <code>update</code>, and the changed value is extracted, converted to <code>std::double</code>, and stored in <code>some_parameter</code>.</p></dd><dt><code>UNPAUSE</code></dt><dd><p>Called when the module is unpaused.</p></dd><dt><code>PAUSE</code></dt><dd><p>Called when the module is paused.</p></dd><dt><code>PERIOD</code></dt><dd><p>Called whenever the real-time period is changed by the Control Panel module.</p></dd><dt><code>EXIT</code></dt><dd><p>Called whenever the module is closed.</p></dd></dl><p>Look though our <a href="/doxygen">doxygen pages</a> to find out how to properly use built-in RTXI functions.</p></div><div><a data-toggle="collapse" data-target="#source7"><div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">PluginTemplate</span><span class="o">::</span><span class="n">customizeGUI</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">QGridLayout</span> <span class="o">*</span><span class="n">customlayout</span> <span class="o">=</span> <span class="n">DefaultGUIModel</span><span class="o">::</span><span class="n">getLayout</span><span class="p">();</span>

   <span class="n">QGroupBox</span> <span class="o">*</span><span class="n">button_group</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QGroupBox</span><span class="p">;</span>

   <span class="n">QPushButton</span> <span class="o">*</span><span class="n">abutton</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">&quot;Button A&quot;</span><span class="p">);</span>
   <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bbutton</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">&quot;Button B&quot;</span><span class="p">);</span>
   <span class="n">QHBoxLayout</span> <span class="o">*</span><span class="n">button_layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QHBoxLayout</span><span class="p">;</span>
   <span class="n">button_group</span><span class="o">-&gt;</span><span class="n">setLayout</span><span class="p">(</span><span class="n">button_layout</span><span class="p">);</span>
   <span class="n">button_layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">abutton</span><span class="p">);</span>
   <span class="n">button_layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bbutton</span><span class="p">);</span>
   <span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">abutton</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">clicked</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">aBttn_event</span><span class="p">()));</span>
   <span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">bbutton</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">clicked</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">bBttn_event</span><span class="p">()));</span>

   <span class="n">customlayout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">button_group</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
   <span class="n">setLayout</span><span class="p">(</span><span class="n">customlayout</span><span class="p">);</span>
<span class="p">}</span></code></pre></div></a></div><div class="collapse" id="source7"><p>The <code>customizeGUI</code> function is designed for users to customize the default UI output created by the <code>DefaultGUIModel</code> class. The initial module is created by the <code>createGUI</code> function called above in the constructor. Broadly speaking, this function takes the output of <code>createGUI</code> and adds custom elements to it. To use this function, you will need to know what the Qt classes are and how to use them properly. Documentation is available on Nokia's website. (<a href="http://doc.qt.io/qt-4.8/">http://doc.qt.io/qt-4.8/</a>)</p><p>To customize the module UI, it first needs to be grabbed and stored in a variable, which is accomplished in the first line of the function. <code>DefaultGUIModel::getLayout()</code> returns an object of type <code>QGridLayout</code>. This essentially is a widget that allows Qt objects to be aligned according to a grid layout. The layout of <code>DefaultGUIModel</code> is as follows:</p><img class="img-responsive" src="/assets/img/tutorials/default_gui_layout.svg" style="max-height:450px"><br><p>By default, the main UI is displayed within the grid at coordinates (1,0) and the utility box with the pause, modify, and exit buttons at coordinates (10,0). All other positions on the grid are empty.</p><p>Note that the size of grid coordinates are arbitrary. They are as big as the widgets that are stuck within them. They're equally-sized in the diagram just for clarity. Look through Qt's documentation for instructions on how to set widgets at specific positions in the grid layout.</p><p>Also, note that coordinates that are empty are not rendered, so there is no big gap between the Main UI and the Button UI because there is nothing put in spots (2,0) to (9,0). Keep in mind, though, that the <code>QGridLayout</code> will not allow objects in diffrent rows to overlap. For example, if you added an object to (1,5), the UI in (0,1) would render, followed by a gap the size of the widget in (1,5), and then the buttons in (0,10). The object in (1,5) would be shown in column 1.</p><p>The rest of the code in <code>customizeGUI</code> creates two buttons and sticks them into coordinate (0,0). The buttons are then connected to functions using Qt's signals and slots API. When a button is pressed, it emits a signal that it has been pressed, and the <code>connect</code> connects that signal to a function. The effect is then to call the function whenever the button is pressed.</p><p>When all the modifications are complete, they need to be added to the module layout that was grabbed by <code>DefaultGUIModel::getLayout()</code>. This is done using the <code>setLayout</code> command.</p></div><div><a data-toggle="collapse" data-target="#source8"><div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">// functions designated as Qt slots are implemented as regular C++ functions</span>
<span class="kt">void</span> <span class="n">PluginTemplate</span><span class="o">::</span><span class="n">aBttn_event</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">void</span> <span class="n">PluginTemplate</span><span class="o">::</span><span class="n">bBttn_event</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span></code></pre></div></a></div><div class="collapse" id="source8"><p>These functions are called whenever their respective buttons are pressed. By default, the functions don't do anything. It is up to users to add what they want.</p></div></div></body><style>html {
  position: relative;
  min-height: 100%;
}
body {
  margin-bottom: 60px;
  margin-top: 10px;
}
.footer {
  position: absolute;
  top: 100%;
  bottom: auto;
  width: 100%;
  height: -60px;
  background-color: #c1c1c1;
}</style><div class="footer"><div class="container"><div class="row"><div class="col-sm-6 text-center" style="margin-top:50px; margin-bottom:10px"><a href="http://www.nih.gov/"><img class="img-responsive" src="/assets/img/nih-logo-trans.svg"></a></div><div class="col-sm-6 text-center" style="margin-top:55px"><a href="https://github.com/rtxi"><img class="img-responsive" src="/assets/img/github-logo.svg"></a></div></div><div style="margin-bottom:40px"></div></div></div><script src="/assets/js/jquery.min.js"></script><script src="/assets/js/bootstrap.min.js"></script></html>