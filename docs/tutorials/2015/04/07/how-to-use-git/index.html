<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>How to Use Git</title><link href="/assets/css/bootstrap.min.css" rel="stylesheet"><link href="/assets/css/pygments.css" rel="stylesheet"><link href="/assets/css/octicons.min.css" rel="stylesheet"><link href="/assets/css/font-awesome.min.css" rel="stylesheet"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="icon" href="/favicon.ico"></head><style>h1, h2, h3, h4, h5, h6 {
      padding-bottom: 9px;
      margin: 40px 0 20px;
      border-bottom: 1px solid #eee;
      font-weight: normal;
   }
   img {
      margin-left: auto;
      margin-right: auto;
      display: block;
      max-width: 100%;
      height: auto;
   }</style><style>body {
   padding-top:50px;
   padding-bottom:30px;
}</style><nav class="navbar navbar-inverse navbar-fixed-top" role="navigation"><div class="container"><div class="navbar-header"><button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" rel="home" href="/"><b>RTXI</b></a></div><div class="row"><div id="navbar" class="navbar-collapse collapse navbar-right" style="text-align:center"><ul class="nav navbar-nav"><li><a href="/install/">Install</a></li><li><a href="/modules/">Modules</a></li><li><a href="/papers/">Papers</a></li><li class="active"><a href="/docs/">Docs</a></li><li><a href="/stats/">Stats</a></li><li><a href="/conference/">Conference</a></li><li><a href="/contact/">Contact</a></li><li><a href="/feed.xml"><i class="fa fa-rss fa-inverse"></i></a></li></ul></div></div></div></nav><body style="padding-top:30px"><div class="container"><h3 class="page-header">How to Use Git</h3><p>Below are instructions for installing and using Git. Git is a version control tool that enables users to track revisions and changes in files and coordinate with collaborators. It is often used for software development.</p><p>Unlike many applications, such as Microsoft Word, editing and saving files overwrites data. This makes it difficult to track changes without creating different file names, a process that can get messy very quickly.</p><p>Git takes snapshots of files a user wants to track and maintains a history of changes that have occurred. This makes backtracking and checking revisions a simple process, which is especially helpful for large projects with many developers. It also functions as a collaborative tool by enabling users to make local copies of a common project and modify them as needed. Users track their own changes and those of others, and Git incorporates tools that enable branching and merging of whatever changes people make.</p><p><a href="http://www.phdcomics.com/comics/archive/phd101212s.gif"><img src="http://www.phdcomics.com/comics/archive/phd101212s.gif" class="img-responsive" style="max-height:400px; float:right; margin:10px"></a></p><p><strong>Note:</strong> Installing git is not the same as using GitHub. GitHub uses git, but it is a remote server that users can use as a central location for storing data. See the instructions for <a href="https://github.com/join">opening a GitHub account</a>.</p><h4 id="installing-git-on-linux">Installing Git on Linux</h4><p>Open the terminal. You can do this from within the Applications menu in GNOME or by using the <code>CTRL+Alt+t</code> shortcut. Enter:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>sudo apt-get install git</code></pre></div><p><strong>Note:</strong> When telling people to enter commands, it is common practice to use <code>$</code> at the start of each line to signify that it is to be entered in the terminal. Also, <code>#</code> is used to signify root permissions rather than having people enter <code>sudo</code>. In either case, you DO NOT have to enter <code>$</code> or <code>#</code> in the terminal. For example, in the above command. just enter the text <code>sudo apt-get install git</code> and hit <code>ENTER</code>.</p><p>Once Git is installed, configure it with your username and/or email address. This is preferred in development scenarios so that everyone can identify what modifications were made by which user. GitHub also maps Git user email addresses to GitHub accounts. Note that you do not have to give your real name. Any name will do, as all that is needed is a way to identify who has done what. Technically, Git does not check email address validity, either, but for collaborate work, it is best to provide some address so that people can ask each other questions about changes.</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git config --global user.name <span class="s1">&#39;Your name here&#39;</span>
<span class="nv">$ </span>git config --global user.email your@address.here</code></pre></div><p>The <code>git</code> part of each command specifies that the script that follows contains Git commands. Git provides a library of functions for executing version control. Rather than have them directly incorporated into system libraries, they are made accessible by preceding the command with <code>git</code>. Therefore, these commands and all other git commands we will use start with <code>git</code>.</p><p>The second part, <code>config</code>, is used to configure information, which is stored in a hidden file. The tag <code>--global</code> means that the changes to the user configuration are to affect all user repositories. The details are saved in a hidden file called .gitconfig stored at the base of the userâ€™s home directory (<code>~/.gitconfig</code>). Other options allow for different scopes of the effects of configuration changes. <code>--local</code> is the default behavior and specifies that changes be written to hidden file in the working directory called <code>.git/config</code>. You can see what has been set in the config files by running <code>git config --list</code>.</p><p><strong>Note:</strong> Should you ever need help with a Git command, you can use <code>git help &lt;commandname&gt;</code> to check the Git documentation in the terminal. For example, if unsure about <code>config</code>, run <code>git help config</code>.</p><h3 id="using-local-repositories">Using Local Repositories</h3><h4 id="initialization">Initialization</h4><p>Git enables users to track local changes and development paths. First, go the base of your home directory and create some new directories:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">cd</span> ~/
<span class="nv">$ </span>mkdir plugins
<span class="nv">$ </span><span class="nb">cd </span>plugins
<span class="nv">$ </span>mkdir practice
<span class="nv">$ </span><span class="nb">cd </span>practice
<span class="nv">$ </span><span class="nb">cd</span> ..</code></pre></div><p>Now, from within the plugins directory, run:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git init</code></pre></div><p>This command specifies that the directory is to be treated as a Git repository. By default, Git does not track <em>any</em> files. User must enable it in a directory of their choosing. Once executed, this function creates a hidden directory called <code>.git/</code> that stores information regarding the repository contained in the directory.</p><p><strong>Note:</strong> Git exists as a version control system. It is not advisable to use it for backing up big files, such as videos, binaries, etc. The entire process gets encumbered quickly.</p><h4 id="a-nameaddaadding-files-to-the-staging-area"><a name="add"></a>Adding Files to the Staging Area</h4><p>The directory is currently empty, so create some files:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>touch file1.txt
<span class="nv">$ </span>touch file2.txt
<span class="nv">$ </span>touch file3.txt</code></pre></div><p>These files have been added to the repository, or in Git terminology, the <strong>working tree</strong>. The working tree refers to all of the files that originate from the base of the directory, which in this case is <code>~/plugins</code>.</p><p>By default, Git does not track files that are added to the directory. Users have to specify that they be tracked. This is done by the <code>add</code> command. Git does, though tell what files are and are not being tracked. Simply use <code>git status</code></p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git add file1.txt file2.txt file3.txt</code></pre></div><p><code>git add</code> adds the files to what is called the <strong>staging area</strong>. Basically, this command generates a snapshot of the files and stores them without adding them to the permanent version history. In other words, Git is aware of the files, but it has not added them to the permanent version history. Basically, git has a 2-stage revision process. The first is to send modified or new files to the staging area, and the second is to commit them to the permanent version history. This has its advantages in that it enables users to add files to a repository as a group that together functions properly. Reverting from one set of changes to another is simply a process of switching to another snapshot in the permanent history. This process is explained later.</p><p>To show what files are in the stating area, use:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git status</code></pre></div><p>If needed, it is possible to unstage files that were added with <code>git add</code>. Git gives the user the command <code>git rm --cached &lt;filename&gt;</code>. Try it on one of the files and see the changes made to the staging area.</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git rm --cached file1.txt
<span class="nv">$ </span>git status</code></pre></div><p>The following assumes that all three files are added to the staging area. You can add all files to the staging area by running <code>git add -A</code>.</p><h4 id="a-namecommitacommiting-files"><a name="commit"></a>Commiting Files</h4><p>With the files added to the staging area, the next step is to add them to the permanent version history. In Git, this process is called a <strong>commit</strong>. Use the <code>commit</code> command.</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git commit file1.txt file2.txt file3.txt -m <span class="s2">&quot;First commit&quot;</span></code></pre></div><p>The <code>commit</code> command adds files in the staging area to the repository. Each commit requires a message that is intended to describe the changes that took place. This can be done in the command line by using <code>-m</code> followed by the message in quotation marks. If this is omitted, Git defaults to a text editor where users can type the message. The <code>commit</code> command is completed when the user saves the message and exits the editor.</p><p>If you opt to not specify the filenames for the commit, git will commit all the files in the staging area.</p><p>Because all the files in the staging area were committed in the last command, there are all removed from the staging area. You can check with <code>git status</code>.</p><p>The version history is in essence a list of commits. To view the complete history of the project, use:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git log</code></pre></div><p>This outputs a list of all the commits, when they were made, the author, the commit messages, and other information. The string at the top of seemingly random letters is an encrypted hash of the changes that were made. A hash is a string that encodes data and is produced by a hash function. Ideally, a hash function is implemented such that a small change in the data it encodes results in a large, unpredictable change in the hash. This enables users to check the fileâ€™s integrity and makes it exceedingly difficult to alter the commit history.</p><h4 id="a-nameundoaoptional-undo-a-commit"><a name="undo"></a>(Optional) Undo a Commit</h4><p>If you ever commit something and wish to revert your changes, use the <code>reset</code> command. There are several options. The first is:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git reset --hard HEAD~1</code></pre></div><p>This command erases <strong>everything</strong> that was altered after the previous commit and sets the working tree to the previous commit. The <code>--hard</code> induces the erasure, and <code>HEAD~1</code> moves to the previous commit. <code>HEAD</code> is a pointer that Git uses to point to a specific commit in a branch. <code>HEAD</code> by default points to the latest commit, so to access previous ones, use <code>~X</code> where X is the number of commits ago you want to go.</p><p>Be very careful when using <code>--hard</code>.</p><p>The second option:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git reset --mixed HEAD~1</code></pre></div><p>-OR-</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git reset HEAD~1</code></pre></div><p>This file preserves the changes made but reverts the HEAD pointer back one commit. The changes are unstaged, so the working directory matches the previous commit.</p><p>The last option:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git reset --soft HEAD~1</code></pre></div><p>The only change is that the most recent commit is reversed. The staging area is the same; it reflects the changes that have been made between the commit to be erased and its predecessor. This option exactly reverses the effects of a <code>git commit</code> command.</p><p>The following assumes that the commit has not been reversed. All three files are committed in the repository.</p><h4 id="a-namebranchabranching-repositories"><a name="branch"></a>Branching Repositories</h4><p>Now that a commit has been made, branch off and create a new working tree. Currently, HEAD points to the last commit of the original branch, called <code>master</code>. This is the default name for a new git repository. It is generally best practice to branch off of master to make changes and then merge changes back to master once they have been thoroughly audited. That way, whatever code is in the master branch is guaranteed to work.</p><p>Create a branch called <code>testing</code>:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git branch testing</code></pre></div><p>This creates a new branch called <code>testing</code>. By default, it copies the state pointed to by HEAD, but it is possible to branch off of previous commits. To list the available branches, use <code>git branch</code>. To switch to the newly created branch, use:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git checkout testing</code></pre></div><p>Now, HEAD is pointing to <code>testing</code> instead of <code>master</code>. Any commits made will be applied to <code>testing</code> as long as it is checked out.</p><h4 id="a-namecommitbranchacommiting-branches"><a name="commitbranch"></a>Commiting Branches</h4><p>Change the current files. This command will add text to the files saying, â€œThis is<filename>". You can use `more<filename>` or `cat<filename>` to output the contents of a file into the terminal.</filename></filename></filename></p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>find . -maxdepth <span class="m">1</span> -type f <span class="p">|</span> xargs -I <span class="o">{}</span> bash -c <span class="s2">&quot;echo &#39;This is &#39;{} &gt; {}&quot;</span></code></pre></div><p>Now that the files have been altered, run <code>git status</code> to see what Git has noticed. Stage the changes and commit them:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git add .
<span class="nv">$ </span>git commit . -m <span class="s2">&quot;First Branch Commit&quot;</span></code></pre></div><p>The <code>.</code> operator causes commands to affect all files in a directory. Using it is easier than typing individual file names.</p><h4 id="a-namecompareacomparing-branches"><a name="compare"></a>Comparing Branches</h4><p>Now that <code>master</code> and <code>testing</code> differ with one another, switch between them to see the differences.</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>ls <span class="p">|</span> xargs cat
<span class="nv">$ </span>git checkout master
<span class="nv">$ </span>ls <span class="p">|</span> xargs cat</code></pre></div><p>Individually looking through files in different branches can be cumbersome. To output the differences directly, use the <code>diff</code> command.</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git diff master testing</code></pre></div><p>The output should look like:</p><h4 id="a-namemergeamerging-branches"><a name="merge"></a>Merging Branches</h4><p>Now, merge the changes in <code>testing</code> to <code>master</code>. Check out the <code>master</code> branch and use the <code>merge</code> command.</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git checkout master
<span class="nv">$ </span>git merge testing</code></pre></div><p>You will see an output that summarizes the changes. The <code>merge</code> command creates a new commit that follows the previous version of <code>master</code>.</p><p>If the merge is successful, there is no need for the <code>testing</code> branch. Delete it. Make sure that the <code>testing</code> branch isnâ€™t currently checked out.</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git branch -d testing</code></pre></div><h3 id="a-namerreposausing-remote-repositories"><a name="rrepos"></a>Using Remote Repositories</h3><p>Remote repositories refer to storage locations outside a userâ€™s local repository. The remote in this example is GitHub, and the repository weâ€™ll be using is for the <a href="https://github.com/rtxi/plugin-template">plugin template</a>. If you want to have your own remote repository on GitHub, you will need to create an account with them and using their website to initialize the repository.</p><h4 id="a-namecloneacloning-a-github-repository"><a name="clone"></a>Cloning a GitHub Repository</h4><p>The format for cloning repositories from GitHub is:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git clone https://github.com/&lt;username&gt;/&lt;repository-name&gt;.git</code></pre></div><p>To clone from our repositories, the username is <code>rtxi</code> and the repositories are all listed on https://github.com/rtxi. To install the plugin template:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">cd</span> ~/ <span class="c"># this line isn&#39;t really needed</span>
<span class="nv">$ </span>git clone https://github.com/rtxi/plugin-template.git
<span class="nv">$ </span><span class="nb">cd </span>plugin-template</code></pre></div><p>In addition to the files copied from GitHub, Git stores the address of the remote repository. By default, the name is <code>origin</code>. See details on remote repositories with <code>git remote -v</code>.</p><h4 id="a-namepushapushing-to-a-remote"><a name="push"></a>Pushing to a Remote</h4><p>Make some changes to the directory. Add some files, edit them, etc. Then, stage and commit them.</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>touch file1 file2 file3
<span class="nv">$ </span>git add .
<span class="nv">$ </span>git commit . <span class="s2">&quot;Local commit to push to remote repository&quot;</span></code></pre></div><p><strong>Note:</strong> You will not actually be able to execute the command below successfully. We donâ€™t allow everyone to push to our repositories. This is what youâ€™d do, though, if you could.</p><p>Now, send these changes to the remote. The command Git uses for this is <code>push</code>.</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git push https://github.com/&lt;username&gt;/plugin-template.git master <span class="c"># will fail</span></code></pre></div><p>Git pushes the changes to the master branch of the remote repository referenced by the URL. Git also supports aliases for remote URLs. By default, the URL from which you clone a repository is saved as <code>origin</code>. You can view the remotes tracked by a repository by running <code>git remote -v</code>.</p><h4 id="a-namepullapulling-changes-from-a-remote"><a name="pull"></a>Pulling Changes from a Remote</h4><p>Just as one can push changes from a local machine to a remote, it is possible to â€˜pullâ€™ changes back from the remote to the local machine. This comes into play when modifying the same project on several machines or by several people. To pull the code and automatically merge the differences, use:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git pull origin</code></pre></div><p>If you want to observe the changes but not merge them, use:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git fetch origin</code></pre></div><p>This command fetches the changes from the remote repository for the user to compare with files on the local machine. Once they are determined to be safe for merging, enter the following from within the directory to which changes are to be merged:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git merge &lt;fetchedremote&gt;</code></pre></div><p>You can use this method to keep your modules and RTXI up to date.</p><h3 id="a-namesummaryasummary"><a name="summary"></a>Summary</h3><p>The above tutorial is a very basic introduction to Git. Git has many functions, and many of them overlap in their functionality. As such, there are often many ways to implement what was described above.</p><p>Should you need more detail, the <a href="http://git-scm.com/documentation">Git documentation</a> is an excellent place to start. Additional help can be found throughout the web:<br>- An <a href="http://try.github.io/levels/1/challenges/1">interactive tutorial</a> for Git syntax.<br>- A <a href="http://www.vogella.com/tutorials/Git/article.html">user-made tutorial</a><br>- A detailed site by Atlassian with <a href="https://www.atlassian.com/git/">tutorials on Git and workflow</a></p></div></body><style>html {
  position: relative;
  min-height: 100%;
}
body {
  margin-bottom: 60px;
  margin-top: 10px;
}
.footer {
  position: absolute;
  top: 100%;
  bottom: auto;
  width: 100%;
  height: -60px;
  background-color: #c1c1c1;
}</style><div class="footer"><div class="container"><div class="row"><div class="col-sm-6 text-center" style="margin-top:50px; margin-bottom:10px"><a href="http://www.nih.gov/"><img class="img-responsive" src="/assets/img/nih-logo-trans.svg"></a></div><div class="col-sm-6 text-center" style="margin-top:55px"><a href="https://github.com/rtxi"><img class="img-responsive" src="/assets/img/github-logo.svg"></a></div></div><div style="margin-bottom:40px"></div></div></div><script src="/assets/js/jquery.min.js"></script><script src="/assets/js/bootstrap.min.js"></script></html>