<!DOCTYPE html><html lang="en" itemscope itemtype="http://schema.org/Article"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Below are instructions for installing and using Git. Git is a version control
tool that enables users to track revisions and changes in files and coordinate
with collaborators. It is often used for..."><meta itemprop="name" content="How to Use Git"><meta itemprop="description" content="Below are instructions for installing and using Git. Git is a version control
tool that enables users to track revisions and changes in files and coordinate
with collaborators. It is often used for..."><meta itemprop="image" content="http://rtxi.org/assets/img/rtxi-logo-square.png"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="How to Use Git"><meta name="twitter:description" content="Below are instructions for installing and using Git. Git is a version control
tool that enables users to track revisions and changes in files and coordinate
with collaborators. It is often used for..."><meta name="twitter:image:src" content="http://rtxi.org/assets/img/rtxi-logo-square.png"><meta property="og:title" content="How to Use Git"><meta property="og:type" content="article"><meta property="og:url" content="http://rtxi.org/docs/tutorials/2015/04/07/how-to-use-git/"><meta property="og:image" content="http://rtxi.org/assets/img/rtxi-logo-square.png"><meta property="og:description" content="Below are instructions for installing and using Git. Git is a version control
tool that enables users to track revisions and changes in files and coordinate
with collaborators. It is often used for..."><meta property="og:site_name" content="RTXI | The Real-time eXperiment Interface"><meta property="article:section" content=""><meta property="article:tag" content=""><title>How to Use Git | The Real-time eXperiment Interface</title><link href="/assets/css/default.min.css" rel="stylesheet"><link rel="apple-touch-icon" href="/assets/img/apple-touch-icon.png"><link rel="icon" href="/assets/img/favicon.ico"></head><style>h1, h2, h3, h4, h5, h6 {
      padding-bottom: 9px;
      margin: 40px 0 20px;
      border-bottom: 1px solid #eee;
      font-weight: normal;
    }
    img {
      margin-left: auto;
      margin-right: auto;
      display: block;
      max-width: 100%;
      height: auto;
    }</style><body><nav class="navbar navbar-inverse navbar-fixed-top" role="navigation"><div class="container"><div class="navbar-header"><button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" rel="home" href="/"><b>RTXI</b></a></div><div class="row"><div id="navbar" class="navbar-collapse collapse navbar-right" style="text-align:center;"><ul class="nav navbar-nav"><li><a href="/install/">Install</a></li><li><a href="/modules/">Modules</a></li><li><a href="/papers/">Papers</a></li><li class="active"><a href="/docs/">Docs</a></li><li><a href="/stats/">Stats</a></li><li><a href="/community/">Community</a></li><li><a href="/contact/">Contact</a></li><li><a href="/feed.xml"><i class="glyphicons glyphicon-rss"></i></a></li></ul></div></div></div></nav><div class="container" style="padding-top:30px"><h3 class="page-header">How to Use Git</h3><p>Below are instructions for installing and using Git. Git is a version control tool that enables users to track revisions and changes in files and coordinate with collaborators. It is often used for software development.</p><p>Unlike many applications, such as Microsoft Word, editing and saving files overwrites data. This makes it difficult to track changes without creating different file names, a process that can get messy very quickly.</p><p>Git takes snapshots of files a user wants to track and maintains a history of changes that have occurred. This makes backtracking and checking revisions a simple process, which is especially helpful for large projects with many developers. It also functions as a collaborative tool by enabling users to make local copies of a common project and modify them as needed. Users track their own changes and those of others, and Git incorporates tools that enable branching and merging of whatever changes people make.</p><p><a href="http://www.phdcomics.com/comics/archive/phd101212s.gif"><img src="http://www.phdcomics.com/comics/archive/phd101212s.gif" class="img-responsive" style="max-height:400px;float:right;margin:10px;"></a></p><p><strong>Note:</strong> Installing git is not the same as using GitHub. GitHub uses git, but it is a remote server that users can use as a central location for storing data. See the instructions for <a href="https://github.com/join">opening a GitHub account</a>.</p><h4 id="installing-git-on-linux">Installing Git on Linux</h4><p>Open the terminal. You can do this from within the Applications menu in GNOME or by using the <code class="language-plaintext highlighter-rouge">CTRL+Alt+t</code> shortcut. Enter:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">sudo </span>apt-get <span class="nb">install </span>git</code></pre></figure><p><strong>Note:</strong> When telling people to enter commands, it is common practice to use <code class="language-plaintext highlighter-rouge">$</code> at the start of each line to signify that it is to be entered in the terminal. Also, <code class="language-plaintext highlighter-rouge">#</code> is used to signify root permissions rather than having people enter <code class="language-plaintext highlighter-rouge">sudo</code>. In either case, you DO NOT have to enter <code class="language-plaintext highlighter-rouge">$</code> or <code class="language-plaintext highlighter-rouge">#</code> in the terminal. For example, in the above command. just enter the text <code class="language-plaintext highlighter-rouge">sudo apt-get install git</code> and hit <code class="language-plaintext highlighter-rouge">ENTER</code>.</p><p>Once Git is installed, configure it with your username and/or email address. This is preferred in development scenarios so that everyone can identify what modifications were made by which user. GitHub also maps Git user email addresses to GitHub accounts. Note that you do not have to give your real name. Any name will do, as all that is needed is a way to identify who has done what. Technically, Git does not check email address validity, either, but for collaborate work, it is best to provide some address so that people can ask each other questions about changes.</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git config <span class="nt">--global</span> user.name <span class="s1">'Your name here'</span>
<span class="nv">$ </span>git config <span class="nt">--global</span> user.email your@address.here</code></pre></figure><p>The <code class="language-plaintext highlighter-rouge">git</code> part of each command specifies that the script that follows contains Git commands. Git provides a library of functions for executing version control. Rather than have them directly incorporated into system libraries, they are made accessible by preceding the command with <code class="language-plaintext highlighter-rouge">git</code>. Therefore, these commands and all other git commands we will use start with <code class="language-plaintext highlighter-rouge">git</code>.</p><p>The second part, <code class="language-plaintext highlighter-rouge">config</code>, is used to configure information, which is stored in a hidden file. The tag <code class="language-plaintext highlighter-rouge">--global</code> means that the changes to the user configuration are to affect all user repositories. The details are saved in a hidden file called .gitconfig stored at the base of the userâ€™s home directory (<code class="language-plaintext highlighter-rouge">~/.gitconfig</code>). Other options allow for different scopes of the effects of configuration changes. <code class="language-plaintext highlighter-rouge">--local</code> is the default behavior and specifies that changes be written to hidden file in the working directory called <code class="language-plaintext highlighter-rouge">.git/config</code>. You can see what has been set in the config files by running <code class="language-plaintext highlighter-rouge">git config --list</code>.</p><p><strong>Note:</strong> Should you ever need help with a Git command, you can use `git help</p><commandname>` to check the Git documentation in the terminal. For example, if unsure about `config`, run `git help config`. ### Using Local Repositories #### Initialization Git enables users to track local changes and development paths. First, go the base of your home directory and create some new directories:<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">cd</span> ~/
<span class="nv">$ </span><span class="nb">mkdir </span>plugins
<span class="nv">$ </span><span class="nb">cd </span>plugins
<span class="nv">$ </span><span class="nb">mkdir </span>practice
<span class="nv">$ </span><span class="nb">cd </span>practice
<span class="nv">$ </span><span class="nb">cd</span> ..</code></pre></figure>Now, from within the plugins directory, run:<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git init</code></pre></figure>This command specifies that the directory is to be treated as a Git repository. By default, Git does not track *any* files. User must enable it in a directory of their choosing. Once executed, this function creates a hidden directory called `.git/` that stores information regarding the repository contained in the directory. **Note:** Git exists as a version control system. It is not advisable to use it for backing up big files, such as videos, binaries, etc. The entire process gets encumbered quickly. #### <a name="add"></a>Adding Files to the Staging Area The directory is currently empty, so create some files:<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">touch </span>file1.txt
<span class="nv">$ </span><span class="nb">touch </span>file2.txt
<span class="nv">$ </span><span class="nb">touch </span>file3.txt</code></pre></figure>These files have been added to the repository, or in Git terminology, the **working tree**. The working tree refers to all of the files that originate from the base of the directory, which in this case is `~/plugins`. By default, Git does not track files that are added to the directory. Users have to specify that they be tracked. This is done by the `add` command. Git does, though tell what files are and are not being tracked. Simply use `git status`<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git add file1.txt file2.txt file3.txt</code></pre></figure>`git add` adds the files to what is called the **staging area**. Basically, this command generates a snapshot of the files and stores them without adding them to the permanent version history. In other words, Git is aware of the files, but it has not added them to the permanent version history. Basically, git has a 2-stage revision process. The first is to send modified or new files to the staging area, and the second is to commit them to the permanent version history. This has its advantages in that it enables users to add files to a repository as a group that together functions properly. Reverting from one set of changes to another is simply a process of switching to another snapshot in the permanent history. This process is explained later. To show what files are in the stating area, use:<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git status</code></pre></figure>If needed, it is possible to unstage files that were added with `git add`. Git gives the user the command `git rm --cached<filename>`. Try it on one of the files and see the changes made to the staging area.<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git <span class="nb">rm</span> <span class="nt">--cached</span> file1.txt
<span class="nv">$ </span>git status</code></pre></figure>The following assumes that all three files are added to the staging area. You can add all files to the staging area by running `git add -A`. #### <a name="commit"></a>Commiting Files With the files added to the staging area, the next step is to add them to the permanent version history. In Git, this process is called a **commit**. Use the `commit` command.<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git commit file1.txt file2.txt file3.txt <span class="nt">-m</span> <span class="s2">"First commit"</span></code></pre></figure>The `commit` command adds files in the staging area to the repository. Each commit requires a message that is intended to describe the changes that took place. This can be done in the command line by using `-m` followed by the message in quotation marks. If this is omitted, Git defaults to a text editor where users can type the message. The `commit` command is completed when the user saves the message and exits the editor. If you opt to not specify the filenames for the commit, git will commit all the files in the staging area. Because all the files in the staging area were committed in the last command, there are all removed from the staging area. You can check with `git status`. The version history is in essence a list of commits. To view the complete history of the project, use:<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git log</code></pre></figure>This outputs a list of all the commits, when they were made, the author, the commit messages, and other information. The string at the top of seemingly random letters is an encrypted hash of the changes that were made. A hash is a string that encodes data and is produced by a hash function. Ideally, a hash function is implemented such that a small change in the data it encodes results in a large, unpredictable change in the hash. This enables users to check the file's integrity and makes it exceedingly difficult to alter the commit history. #### <a name="undo"></a>(Optional) Undo a Commit If you ever commit something and wish to revert your changes, use the `reset` command. There are several options. The first is:<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git reset <span class="nt">--hard</span> HEAD~1</code></pre></figure>This command erases **everything** that was altered after the previous commit and sets the working tree to the previous commit. The `--hard` induces the erasure, and `HEAD~1` moves to the previous commit. `HEAD` is a pointer that Git uses to point to a specific commit in a branch. `HEAD` by default points to the latest commit, so to access previous ones, use `~X` where X is the number of commits ago you want to go. Be very careful when using `--hard`. The second option:<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git reset <span class="nt">--mixed</span> HEAD~1</code></pre></figure>-OR-<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git reset HEAD~1</code></pre></figure>This file preserves the changes made but reverts the HEAD pointer back one commit. The changes are unstaged, so the working directory matches the previous commit. The last option:<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git reset <span class="nt">--soft</span> HEAD~1</code></pre></figure>The only change is that the most recent commit is reversed. The staging area is the same; it reflects the changes that have been made between the commit to be erased and its predecessor. This option exactly reverses the effects of a `git commit` command. The following assumes that the commit has not been reversed. All three files are committed in the repository. #### <a name="branch"></a>Branching Repositories Now that a commit has been made, branch off and create a new working tree. Currently, HEAD points to the last commit of the original branch, called `master`. This is the default name for a new git repository. It is generally best practice to branch off of master to make changes and then merge changes back to master once they have been thoroughly audited. That way, whatever code is in the master branch is guaranteed to work. Create a branch called `testing`:<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git branch testing</code></pre></figure>This creates a new branch called `testing`. By default, it copies the state pointed to by HEAD, but it is possible to branch off of previous commits. To list the available branches, use `git branch`. To switch to the newly created branch, use:<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git checkout testing</code></pre></figure>Now, HEAD is pointing to `testing` instead of `master`. Any commits made will be applied to `testing` as long as it is checked out. #### <a name="commitbranch"></a>Commiting Branches Change the current files. This command will add text to the files saying, "This is<filename>". You can use `more<filename>` or `cat<filename>` to output the contents of a file into the terminal.<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>find <span class="nb">.</span> <span class="nt">-maxdepth</span> 1 <span class="nt">-type</span> f | xargs <span class="nt">-I</span> <span class="o">{}</span> bash <span class="nt">-c</span> <span class="s2">"echo 'This is '{} &gt; {}"</span></code></pre></figure>Now that the files have been altered, run `git status` to see what Git has noticed. Stage the changes and commit them:<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git add <span class="nb">.</span>
<span class="nv">$ </span>git commit <span class="nb">.</span> <span class="nt">-m</span> <span class="s2">"First Branch Commit"</span></code></pre></figure>The `.` operator causes commands to affect all files in a directory. Using it is easier than typing individual file names. #### <a name="compare"></a>Comparing Branches Now that `master` and `testing` differ with one another, switch between them to see the differences.<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">ls</span> | xargs <span class="nb">cat</span>
<span class="nv">$ </span>git checkout master
<span class="nv">$ </span><span class="nb">ls</span> | xargs <span class="nb">cat</span></code></pre></figure>Individually looking through files in different branches can be cumbersome. To output the differences directly, use the `diff` command.<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git diff master testing</code></pre></figure>The output should look like: #### <a name="merge"></a>Merging Branches Now, merge the changes in `testing` to `master`. Check out the `master` branch and use the `merge` command.<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git checkout master
<span class="nv">$ </span>git merge testing</code></pre></figure>You will see an output that summarizes the changes. The `merge` command creates a new commit that follows the previous version of `master`. If the merge is successful, there is no need for the `testing` branch. Delete it. Make sure that the `testing` branch isn't currently checked out.<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git branch <span class="nt">-d</span> testing</code></pre></figure>### <a name="rrepos"></a>Using Remote Repositories Remote repositories refer to storage locations outside a user's local repository. The remote in this example is GitHub, and the repository we'll be using is for the <a href="https://github.com/rtxi/plugin-template">plugin template</a>. If you want to have your own remote repository on GitHub, you will need to create an account with them and using their website to initialize the repository. #### <a name="clone"></a>Cloning a GitHub Repository The format for cloning repositories from GitHub is:<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git clone https://github.com/&lt;username&gt;/&lt;repository-name&gt;.git</code></pre></figure>To clone from our repositories, the username is `rtxi` and the repositories are all listed on https://github.com/rtxi. To install the plugin template:<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">cd</span> ~/ <span class="c"># this line isn't really needed</span>
<span class="nv">$ </span>git clone https://github.com/rtxi/plugin-template.git
<span class="nv">$ </span><span class="nb">cd </span>plugin-template</code></pre></figure>In addition to the files copied from GitHub, Git stores the address of the remote repository. By default, the name is `origin`. See details on remote repositories with `git remote -v`. #### <a name="push"></a>Pushing to a Remote Make some changes to the directory. Add some files, edit them, etc. Then, stage and commit them.<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">touch </span>file1 file2 file3
<span class="nv">$ </span>git add <span class="nb">.</span>
<span class="nv">$ </span>git commit <span class="nb">.</span> <span class="s2">"Local commit to push to remote repository"</span></code></pre></figure>**Note:** You will not actually be able to execute the command below successfully. We don't allow everyone to push to our repositories. This is what you'd do, though, if you could. Now, send these changes to the remote. The command Git uses for this is `push`.<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git push https://github.com/&lt;username&gt;/plugin-template.git master <span class="c"># will fail</span></code></pre></figure>Git pushes the changes to the master branch of the remote repository referenced by the URL. Git also supports aliases for remote URLs. By default, the URL from which you clone a repository is saved as `origin`. You can view the remotes tracked by a repository by running `git remote -v`. #### <a name="pull"></a>Pulling Changes from a Remote Just as one can push changes from a local machine to a remote, it is possible to 'pull' changes back from the remote to the local machine. This comes into play when modifying the same project on several machines or by several people. To pull the code and automatically merge the differences, use:<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git pull origin</code></pre></figure>If you want to observe the changes but not merge them, use:<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git fetch origin</code></pre></figure>This command fetches the changes from the remote repository for the user to compare with files on the local machine. Once they are determined to be safe for merging, enter the following from within the directory to which changes are to be merged:<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git merge &lt;fetchedremote&gt;</code></pre></figure>You can use this method to keep your modules and RTXI up to date. ### <a name="summary"></a>Summary The above tutorial is a very basic introduction to Git. Git has many functions, and many of them overlap in their functionality. As such, there are often many ways to implement what was described above. Should you need more detail, the [Git documentation](http://git-scm.com/documentation) is an excellent place to start. Additional help can be found throughout the web: - An [interactive tutorial](http://try.github.io/levels/1/challenges/1) for Git syntax. - A [user-made tutorial](http://www.vogella.com/tutorials/Git/article.html) - A detailed site by Atlassian with [tutorials on Git and workflow](https://www.atlassian.com/git/)</filename></filename></filename></filename></commandname></div></body><style>html {
  position: relative;
  min-height: 100%;
}
body {
  margin-bottom: 60px;
  margin-top: 10px;
}
.footer {
  position: absolute;
  top: 100%;
  bottom: auto;
  width: 100%;
  height: -60px;
  background-color: #c1c1c1;
}</style><div class="footer"><div class="container"><div class="row"><div class="col-sm-6 text-center" style="margin-top:50px; margin-bottom:10px"><a href="http://www.nih.gov/"><img class="img-responsive" alt="NIH grant 2R01EB016407-09" src="/assets/img/nih-logo-trans.svg"></a></div><div class="col-sm-6 text-center" style="margin-top:55px;"><a href="https://github.com/rtxi"><img class="img-responsive" alt="RTXI on GitHub" src="/assets/img/github-logo.svg"></a></div></div><div style="margin-bottom:40px;"></div></div></div><script src="/assets/js/default.min.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-5550734-5', 'auto');
    ga('send', 'pageview');</script></html>