<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>RTXI</title>
    <description>RTXI is a fast, open-source system for hard real-time, closed-loop data acquisition and stimulation for electrophysiology experiments.</description>
    <link>http://rtxi.org</link>
    <atom:link href="http://rtxi.org/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>RTXI 2015 Registration Open!</title>
        <description>&lt;p&gt;Just reminding everyone that registration for RTXI 2015 is now open! Check out our &lt;a href=&quot;/conference/&quot;&gt;conference page&lt;/a&gt; to learn about our upcoming conference. &lt;a href=&quot;http://petitinstitute.gatech.edu/rtxi-2015-workshop&quot;&gt;Registration is open&lt;/a&gt; until April 1st at 5:00 PM Eastern Time.  &lt;/p&gt;
</description>
        <pubDate>Wed, 21 Jan 2015 00:00:00 -0500</pubDate>
        <link>http://rtxi.org//news/2015/01/21/rtxi-2015-registration-is-open/</link>
        <guid isPermaLink="true">http://rtxi.org//news/2015/01/21/rtxi-2015-registration-is-open/</guid>
      </item>
    
      <item>
        <title>Why are there negative latencies?</title>
        <description>&lt;p&gt;Negative latencies mean that the latency test has not been properly calibrated. The test calculates latencies based on when tasks are expected to be completed, and in doing so, it attempts to account for jitter in the system. Latencies become negative when the real-time thread wakes &lt;em&gt;before&lt;/em&gt; it is expected to.  &lt;/p&gt;

&lt;p&gt;You can correct this behavior by running (as root):  &lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# echo 0 &amp;gt; /proc/xenomai/latency&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

</description>
        <pubDate>Tue, 20 Jan 2015 00:00:00 -0500</pubDate>
        <link>http://rtxi.org//docs/faqs/2015/01/20/why-are-there-negative-latencies/</link>
        <guid isPermaLink="true">http://rtxi.org//docs/faqs/2015/01/20/why-are-there-negative-latencies/</guid>
      </item>
    
      <item>
        <title>Register for RTXI 2015</title>
        <description>&lt;p&gt;If you haven’t done so already, check out our &lt;a href=&quot;/conference/&quot;&gt;conference page&lt;/a&gt; to learn about our upcoming conference. Registration is almost open. We just need to get the payment page running.  &lt;/p&gt;
</description>
        <pubDate>Mon, 22 Dec 2014 00:00:00 -0500</pubDate>
        <link>http://rtxi.org//news/2014/12/22/register-for-RTXI-2015/</link>
        <guid isPermaLink="true">http://rtxi.org//news/2014/12/22/register-for-RTXI-2015/</guid>
      </item>
    
      <item>
        <title>Let There Be News!</title>
        <description>&lt;p&gt;There is now a news section on the home page! Look in future for an RSS feed.   &lt;/p&gt;

&lt;p&gt;This page is more for me to test that my automation ‘scripts’ are working than to tell you anything remotely substantive.  &lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;I think I’ll add another news post after this one just to check if the spacing works out alright.  &lt;/p&gt;
</description>
        <pubDate>Mon, 22 Dec 2014 00:00:00 -0500</pubDate>
        <link>http://rtxi.org//news/2014/12/22/let-there-be-news/</link>
        <guid isPermaLink="true">http://rtxi.org//news/2014/12/22/let-there-be-news/</guid>
      </item>
    
      <item>
        <title>New Website</title>
        <description>&lt;p&gt;We now have a new website. It’s not quite feature-rich yet, but it’s a nice, fresh site to coincide with the long-planned release of RTXI 2.0. Look here in the future for all documentation, tutorials, videos, etc. related to using RTXI and closed-loop, real-time electrophysiology in general. 
While not complete, the new site got a few things ready that we think you’ll like:  &lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;/modules/&quot;&gt;&lt;strong&gt;The Modules Page:&lt;/strong&gt;&lt;/a&gt; the old site contained a modules page that was perpetually out-of-date relative to current RTXI development. The new page is autogenerated by pulling directly from our GitHub repos, so they’ll stay up-to-date. It also has a search feature absent from GitHub’s own site.  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/papers/&quot;&gt;&lt;strong&gt;The Papers Page:&lt;/strong&gt;&lt;/a&gt; built with the restraint of a 5-year-old kid with a free pass to an all-you-use Javascript plugin candy store, the papers page will give you picture of just how many people have used RTXI over the years and what they did with it.  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/docs/&quot;&gt;&lt;strong&gt;Documentation:&lt;/strong&gt;&lt;/a&gt; all our documentation is easier to find and all accessible from a single page. At any rate, it’ll be easier to find what you need this way than it would be to search through pages of Wordpress blog posts.  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;It’s Lighter and Faster:&lt;/strong&gt; this is mostly for my gratification, but the new site is leaner and faster than the old one.  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If there’s something on the old site that you used that’s gone now, just let us know. We’ll get it back for you. There are &lt;a href=&quot;/contact/&quot;&gt;lots of ways to contact us&lt;/a&gt;. Thanks.&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Dec 2014 00:00:00 -0500</pubDate>
        <link>http://rtxi.org//news/2014/12/10/new-website/</link>
        <guid isPermaLink="true">http://rtxi.org//news/2014/12/10/new-website/</guid>
      </item>
    
      <item>
        <title>What Is Real-time Computing?</title>
        <description>&lt;p&gt;In general, an operating system is responsible for managing the hardware resources of a computer. A real-time operating system is a refinement in that it perfoms tasks with extreme precision and reliability. This is important in automated process control systems where a delay can cause a critical failure of the overall system.  &lt;/p&gt;

&lt;h4 id=&quot;hard-vs-soft-real-time&quot;&gt;Hard vs. Soft Real-time&lt;/h4&gt;

&lt;p&gt;To be considered real-time, an operating system must have a known maximum time for each of the operations that it performs. Operating systems that can absolutely guarantee a maximum time for these operations are called hard real-time, while operating systems that can only guarantee a maximum most of the time are considered soft real-time. The idea is that in a hard real-time system, the completion of an operation after its deadline is considered useless, and in the most non-permissive of systems, for instance car brakes, missed deadlines constitute system failure. In contrast, a soft real-time system can handle lateness, usually by pausing processes based on some execution priority scheme.  &lt;/p&gt;

&lt;p&gt;Most operating systems allow programmers to specify a priority for the overall application and even for different tasks within the application, called threads. These priorities are handled by the operating system’s scheduler, which decides how to allocate system resources when many tasks need to be executed more or less simultaneously and whether or not to interrupt a task when those with higher priority are waiting.  &lt;/p&gt;

&lt;p&gt;In practice, general-purpose operating systems, such as Microsoft Windows, are optimized to run a variety of applications and processes simultaneously. Windows uses system interrupts to distribute processor time between different tasks that must access the same shared resources. Standard Linux does the same. It can be made to run in real-time, though, by inserting a small high-priority, real-time microkernel between the hardware and standard Linux kernel. The microkernel’s scheduler traps any software-related system interrupts that would otherwise preempt system resources from any real-time tasks it executes, thereby guaranteeing that real-time tasks are not interrupted and execute with higher priority than normal Linux processes. RTXI uses a real-time thread for actual process control and a non-realtime thread handled by standard Linux for the graphical user interface.  &lt;/p&gt;

&lt;h4 id=&quot;what-real-time-can-do&quot;&gt;What Real-time Can Do&lt;/h4&gt;

&lt;p&gt;A real-time process control system must constantly process a set of inputs and produce a set of outputs. Real-time applications must be carefully programmed to ensure that the total amount of time spent accessing the hardware, sampling the inputs, computing the outputs, and interacting with any user interface is no longer than the specified cycle time.&lt;/p&gt;

&lt;p&gt;Xenomai provides several benchmark tests for system latencies. RTXI also has a Performance Measurement module that determines average and worst case real-time performance within RTXI. Maximal performance depends mostly on the motherboard and supporting chipset, not as much on processor speed. Instead, the processor determines the complexity of the models the system can solve within the constraints of some underlying real-time computation rate. Faster processors allow more instructions to be executed per computational cycle. For example, a complex model may require too much computation to work on a 200MHz machine, but will run at 20kHz on a 2GHz machine, even though a much simpler model runs at 50kHz on both. A slower processor simply cannot execute instructions in complex models quickly enough.  &lt;/p&gt;

&lt;h4 id=&quot;measuring-performance&quot;&gt;Measuring Performance&lt;/h4&gt;

&lt;p&gt;The ‘speed’ of a platform usually refers to three attributes: time step, jitter, and latency. The time step is the target period of the system. Ideally, this value would be infinitesimal so that we would be able to acquire and output all possible frequencies; however, that cannot be realized in practice because a set amount of processing time is needed for input-output calculations. This set time provides a lower bound for overall computation time, but systems get pulled away from it due to the costs mentioned earlier. Essentially, the actual observable time step is a random variable centered about a mean target time step. The second term, jitter, describes the variation around the mean, and is a direct result of the non-deterministic nature of modern computer architectures (e.g. cache misses, bus contention, and super-scalar execution). Typically, solutions based on general purpose operating systems will always suffer from high levels of jitter because the underlying system is designed to distribute clock cycles fairly among many competing processes. Latency, the time between receiving an input and updating the corresponding physical output channel roughly determines the lower bound on time step. Latency exists because it takes a finite amount of time to perform analog to digital conversion, do some computation, and convert back from digital to analog.  &lt;/p&gt;
</description>
        <pubDate>Sat, 06 Dec 2014 00:00:00 -0500</pubDate>
        <link>http://rtxi.org//docs/tutorials/2014/12/06/what-is-real-time-computing/</link>
        <guid isPermaLink="true">http://rtxi.org//docs/tutorials/2014/12/06/what-is-real-time-computing/</guid>
      </item>
    
      <item>
        <title>RTXI Architecture</title>
        <description>&lt;p&gt;RTXI uses a two-thread architecture consisting of a real-time (RT) thread and a non-real-time user interface (UI) thread. RTXI can run on single or multiprocessor computers. RTXI consists of both system and custom user modules, each of which spans both threads. RTXI modules communicate and share data in real-time using a system of signals and slots that supports synchronous scheduling, as well as asynchronous event handling. On every clock cycle, the RT thread wakes and signals each active DAQ driver to acquire all active inputs from external experiment hardware. These data are made available to other components while the RT thread executes any real-time instructions contained in loaded modules. When each module has finished executing, the RT thread signals each DAQ driver to write any output signals to the experiment hardware. The UI thread manages the graphical components of the system as well as user events triggered through the interface. Each module features its own encapsulated interface through which users can control module execution and modify its various parameters.  &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/img/rtxi-diagram-scaled.png&quot;&gt;
   &lt;img src=&quot;/assets/img/rtxi-diagram-scaled.png&quot; class=&quot;img-responsive center-block&quot; /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;RTXI uses the open source &lt;a href=&quot;https://xenomai.org&quot;&gt;Xenomai&lt;/a&gt; framework to implement communication with a variety of commercially available multifunction DAQ cards with both analog and digital input and output channels. This makes RTXI essentially hardware-agnostic and able to communicate with multiple actuators and sensors that may span different modalities. Modules contain function-specific code that can be used in combinations to build custom workflows and experiment protocols. They are compiled outside the core RTXI source tree as shared object libraries that are linked at runtime. This architecture gives RTXI several important features:  &lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Reduced overhead that maximizes real-time performance by loading a minimal set of modules at startup&lt;/li&gt;
  &lt;li&gt;Code reusability which eliminates the need to program new experiments entirely from scratch&lt;/li&gt;
  &lt;li&gt;Ease by which users can share modules by distributing source code or compiled versions of their modules&lt;/li&gt;
  &lt;li&gt;The ability to create and save the entire RTXI workspace and experimental setup for use at a later date&lt;/li&gt;
  &lt;li&gt;A simple process by which multiple developers can contribute new features with minimal changes to core RTXI source code.&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sat, 06 Dec 2014 00:00:00 -0500</pubDate>
        <link>http://rtxi.org//docs/tutorials/2014/12/06/rtxi-architecture/</link>
        <guid isPermaLink="true">http://rtxi.org//docs/tutorials/2014/12/06/rtxi-architecture/</guid>
      </item>
    
      <item>
        <title>RTXI and Dynamic Clamp</title>
        <description>&lt;p&gt;The dynamic clamp is a real-time electrophysiology technique where simulated membrane conductances are artificially injected into a cell via intracellular electrodes. It works by reading membrane potentials, amplifiing, and then feeding them into a dynamic clamp system that contains a model of the desired membrane conductance and generates a current to be injected back into the cell in real time. For digital systems, the membrane conductance is a set of equations that must be computed, whereas for an analog system, the current is the output of a dedicated electrical circuit. The injected dynamic clamp current acts on the cell in parallel with other membrane currents which, depending on the model equations, can represent ion channels, electrical coupling between cells, or synaptic input. This technique has many possible uses. With neurons, it can be used to construct hybrid networks of real and model neurons and even attach virtual dendrites. For an excellent video tutorial, see this video for the following paper in the Journal of Visualized Experiments.  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/dclamp.png&quot; alt=&quot;Dynamic Clamp Figure&quot; /&gt;  &lt;/p&gt;

&lt;h4 id=&quot;electrode-compensation-and-dynamic-clamp-instability&quot;&gt;Electrode Compensation and Dynamic Clamp Instability&lt;/h4&gt;
&lt;p&gt;When dynamic clamp is performed using two intracellular electrodes, one electrode records the membrane potential while the other is used for current injection. In cases where only one intracellular electrode is feasible, the same electrode is used for voltage measurement and current injection. This poses a problem for measurement accuracy because the injected current induces a voltage drop through the electrode. One method to compensate for this issue is to use your amplifier in “bridge balance” mode, which approximates the electrode as a single resistance and subtracts the voltage drop across the electrode from the total recorded voltage. This method can only be used if the electrode resistance stays constant. An alternative method is to operate your amplifier in “discontinuous current clamp” mode, in which the electrode alternates between recording the voltage and injecting current. This method is valid only if the electrode is at least two orders of magnitude faster than what you are trying to observe in the recordings.  &lt;/p&gt;

&lt;p&gt;It is important to minimize measurement errors in dynamic clamp because the artifacts propagate through the closed-loop and can lead to oscillatory instability. This instability arises when the artificial conductance is comparable to the resting input conductance of the cell and limits the conductance range that can be applied using dynamic clamp. It is directly related to the sampling delay and is exaggerated by insufficient electrode series resistance and capacitance compensation. Increasing the sampling rate of the dynamic clamp system increases dynamic clamp stability; however, this improvement, is constrained by how well the electrode series resistance and capacitance are compensated. Dynamic clamp sampling rates are usually justified by the temporal dynamics of the simulated models. For action potentials on the order of a few milliseconds wide, 10kHz is a common sampling rate. However, faster sampling rates increase the stable operating range for the dynamic clamp system and increase the maximum conductance that maintains a stable system. RTXI is capable of handling much higher sampling rates due to the low overhead in the Linux OS.  &lt;/p&gt;

&lt;h4 id=&quot;numerical-methods&quot;&gt;Numerical Methods&lt;/h4&gt;
&lt;p&gt;Similar to the effect of experimental measurement error, errors in simulating the virtual conductance also affect dynamic clamp performance. Methodologies for implementing the numerical integration of the gating variables typically employ first-order numerical methods, either Euler or exponential Euler. These approximations are used because of the real-time temporal constraints on how rapidly the calculations for integrating the gating variables must occur. In general, numerical accuracy increases as the time step of integration decreases. Unlike traditional model simulations, however, with real-time systems it is not practical to make the time step smaller and simply wait longer for the simulation result. For small time steps, both integration methods are comparable, but at larger time steps, the exponential Euler method performs worse than the Euler method. The error bounds for both methods can be characterized in terms of two ratios: the time step over the time constant (δt/τ), and the voltage measurement error over the slope factor of the steady-state activation curve of the voltage-dependent gating variable (εV/|d|). When δt/τ is large relative to εV/|d|, no amount of improvement in measurement error can improve the error bound due to the numerical inaccuracies caused by a relatively large time step.  &lt;/p&gt;

&lt;p&gt;For more information, see:   &lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://dx.doi.org/10.3791/2275&quot;&gt;Lobb and Paladini. Application of a NMDA Receptor Conductance in Rat Midbrain Dopaminergic Neurons Using the Dynamic Clamp Technique. J Vis Exp (2010) (46)&lt;/a&gt;   &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.springer.com/biomed/neuroscience/book/978-0-387-89278-8&quot;&gt;Destexhe A, Bal T, eds. Dynamic clamp: From principles to applications. Springer (2009).&lt;/a&gt;  &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://dx.doi.org/10.1016/j.jneumeth.2007.10.009&quot;&gt;Bettencourt J.C., Lillis K.P., Stupin L.R., White J.A. Effects of imperfect dynamic clamp: Computational and experimental results (2008) Journal of Neuroscience Methods, 169 (2): 282-289.&lt;/a&gt;  &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://dx.doi.org/10.1088/1741-2560%2F1%2F4%2F001&quot;&gt;R.J. Butera and M.L. McCarthy. Analysis of real-time numerical integration methods applied to dynamic clamp experiments, J. Neural Eng. 1 (2004), pp. 187–194.&lt;/a&gt;  &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://dx.doi.org/10.1016/j.tins.2004.02.004&quot;&gt;Prinz AA, Abbott LF, Marder E. The dynamic clamp comes of age. (2004) TINS 27: 218–224.&lt;/a&gt;  &lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 05 Dec 2014 00:00:00 -0500</pubDate>
        <link>http://rtxi.org//docs/tutorials/2014/12/05/dyamic-clamp/</link>
        <guid isPermaLink="true">http://rtxi.org//docs/tutorials/2014/12/05/dyamic-clamp/</guid>
      </item>
    
      <item>
        <title>RTXI HDF5 Data Files</title>
        <description>&lt;p&gt;The HDF5 file format is a portable and extensible binary data format designed for complex data. It features support for an unlimited variety of datatypes, and has flexible and efficient I/O. HDF5 features a hierarchical structure that allows you to access chunks of data without loading the entire file into memory. An HDF5 file produced by RTXI’s Data Recorder is organized as shown on the right:  &lt;/p&gt;

&lt;div class=&quot;container&quot;&gt;
   &lt;div class=&quot;col-sm-4&quot;&gt;
      &lt;a href=&quot;/assets/img/hdf5-rtxi.png&quot;&gt;&lt;img src=&quot;/assets/img/hdf5-rtxi.png&quot; class=&quot;img-responsive&quot; /&gt;&lt;/a&gt;
   &lt;/div&gt;
   &lt;div class=&quot;col-sm-8&quot;&gt;
      &lt;a href=&quot;/assets/img/hdf5-rtxi-2.png&quot;&gt;&lt;img src=&quot;/assets/img/hdf5-rtxi-2.png&quot; class=&quot;img-responsive&quot; /&gt;&lt;/a&gt;
   &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;At the topmost level, an RTXI HDF5 file is divided into separate &lt;strong&gt;Trial&lt;/strong&gt; groups, each of which contains the complete set of system options, module settings, and model parameter values that existed at the time that data was recorded. Every time you stop and restart a module from which data is sent to the Data Recorder, a new Trial is created. Each Trial is timestamped with a start and end time. The Data Recorder also has the option to append trials to an existing HDF5 file. For this reason, each Trial has its own data and system attributes.  &lt;/p&gt;

&lt;p&gt;The parameters for modules and all system settings are saved in the &lt;strong&gt;Parameters&lt;/strong&gt; group within each Trial group. The name of each parameter includes the module ID number within RTXI, the name of the module, and the name of the parameter itself. If the value of the parameter changes during recording, all the values are saved with a corresponding index value that is the timestamp in nanoseconds from the start of the recording.  &lt;/p&gt;

&lt;p&gt;The real-time data is saved in the &lt;strong&gt;Synchronous&lt;/strong&gt; group within each Trial group. This group contains separate datasets with the name of each channel and a single dataset that contains all the synchronous data.&lt;/p&gt;

&lt;p&gt;There are various software available for working with HDF5 files. To simply browse the file structure, you can use the free HDFView application. HDFView provides some limited editing capabilities. For trials where only a single channel is saved, you can also preview a plot of the data. To extract the data for analysis and for complete editing capabilities, APIs are available for MATLAB, GNU Octave, Igor Pro, Mathematica, Python, Scilab, and other software. See this list maintained by the HDF Group.&lt;/p&gt;

&lt;p&gt;We provide here a collection of MATLAB functions and a simple GUI for browsing through the trials of an RTXI v1.3 HDF5 file with addtional examples of how to extract data and add new datasets to your file. &lt;strong&gt;To load RTXI HDF5 files into MATLAB, you no longer need to “matlabize” your HDF5 files, provided you use the MATLAB functions in RTXIh5.zip.&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Dec 2014 00:00:00 -0500</pubDate>
        <link>http://rtxi.org//docs/tutorials/2014/12/04/rtxi-hdf5-data-files/</link>
        <guid isPermaLink="true">http://rtxi.org//docs/tutorials/2014/12/04/rtxi-hdf5-data-files/</guid>
      </item>
    
      <item>
        <title>Manually Configuring RTXI</title>
        <description>&lt;p&gt;You can manually configure RTXI with many options. For example, you can run RTXI 2.0 using the RTAI rather than the default Xenomai, and you can set up RTXI in non-real-time mode using the POSIX interface. You may also direct RTXI to libraries/packages in non-standard locations. The full configure options for are below:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;configure&lt;span class=&quot;s1&quot;&gt;&amp;#39; configures RTXI trunk to adapt to many kinds of systems.&lt;/span&gt;

&lt;span class=&quot;s1&quot;&gt;Usage: ./configure [OPTION]... [VAR=VALUE]...&lt;/span&gt;

&lt;span class=&quot;s1&quot;&gt;To assign environment variables (e.g., CC, CFLAGS...), specify them as&lt;/span&gt;
&lt;span class=&quot;s1&quot;&gt;VAR=VALUE.  See below for descriptions of some of the useful variables.&lt;/span&gt;

&lt;span class=&quot;s1&quot;&gt;Defaults for the options are specified in brackets.&lt;/span&gt;

&lt;span class=&quot;s1&quot;&gt;Configuration:&lt;/span&gt;
&lt;span class=&quot;s1&quot;&gt;  -h, --help              display this help and exit&lt;/span&gt;
&lt;span class=&quot;s1&quot;&gt;      --help=short        display options specific to this package&lt;/span&gt;
&lt;span class=&quot;s1&quot;&gt;      --help=recursive    display the short help of all the included packages&lt;/span&gt;
&lt;span class=&quot;s1&quot;&gt;  -V, --version           display version information and exit&lt;/span&gt;
&lt;span class=&quot;s1&quot;&gt;  -q, --quiet, --silent   do not print `checking...&amp;#39;&lt;/span&gt; messages
      --cache-file&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;FILE   cache &lt;span class=&quot;nb&quot;&gt;test &lt;/span&gt;results in FILE &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;disabled&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  -C, --config-cache      &lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;--cache-file&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;config.cache&lt;span class=&quot;s1&quot;&gt;&amp;#39;&lt;/span&gt;
&lt;span class=&quot;s1&quot;&gt;  -n, --no-create         do not create output files&lt;/span&gt;
&lt;span class=&quot;s1&quot;&gt;      --srcdir=DIR        find the sources in DIR [configure dir or `..&amp;#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

Installation directories:
  --prefix&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;PREFIX         install architecture-independent files in PREFIX
                          &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/usr/local&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --exec-prefix&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;EPREFIX   install architecture-dependent files in EPREFIX
                          &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;PREFIX&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

By default, &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;make install&lt;span class=&quot;s1&quot;&gt;&amp;#39; will install all the files in&lt;/span&gt;
&lt;span class=&quot;s1&quot;&gt;`/usr/local/bin&amp;#39;&lt;/span&gt;, &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;/usr/local/lib&lt;span class=&quot;s1&quot;&gt;&amp;#39; etc.  You can specify&lt;/span&gt;
&lt;span class=&quot;s1&quot;&gt;an installation prefix other than `/usr/local&amp;#39;&lt;/span&gt; using &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;--prefix&lt;span class=&quot;s1&quot;&gt;&amp;#39;,&lt;/span&gt;
&lt;span class=&quot;s1&quot;&gt;for instance `--prefix=$HOME&amp;#39;&lt;/span&gt;.

For better control, use the options below.

Fine tuning of the installation directories:
  --bindir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR            user executables &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;EPREFIX/bin&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --sbindir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR           system admin executables &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;EPREFIX/sbin&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --libexecdir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR        program executables &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;EPREFIX/libexec&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --sysconfdir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR        &lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt;-only single-machine data &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;PREFIX/etc&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --sharedstatedir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR    modifiable architecture-independent data &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;PREFIX/com&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --localstatedir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR     modifiable single-machine data &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;PREFIX/var&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --libdir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR            object code libraries &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;EPREFIX/lib&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --includedir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR        C header files &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;PREFIX/include&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --oldincludedir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR     C header files &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; non-gcc &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/usr/include&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --datarootdir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR       &lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt;-only arch.-independent data root &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;PREFIX/share&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --datadir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR           &lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt;-only architecture-independent data &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;DATAROOTDIR&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --infodir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR           info documentation &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;DATAROOTDIR/info&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --localedir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR         locale-dependent data &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;DATAROOTDIR/locale&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --mandir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR            man documentation &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;DATAROOTDIR/man&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --docdir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR            documentation root &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;DATAROOTDIR/doc/rtxi&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --htmldir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR           html documentation &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;DOCDIR&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --dvidir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR            dvi documentation &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;DOCDIR&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --pdfdir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR            pdf documentation &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;DOCDIR&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --psdir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR             ps documentation &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;DOCDIR&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

Program names:
  --program-prefix&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;PREFIX            prepend PREFIX to installed program names
  --program-suffix&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;SUFFIX            append SUFFIX to installed program names
  --program-transform-name&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;PROGRAM   run sed PROGRAM on installed program names

X features:
  --x-includes&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR    X include files are in DIR
  --x-libraries&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR   X library files are in DIR

System types:
  --build&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;BUILD     configure &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; building on BUILD &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;guessed&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --host&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;HOST       cross-compile to build programs to run on HOST &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;BUILD&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

Optional Features:
  --disable-option-checking  ignore unrecognized --enable/--with options
  --disable-FEATURE       &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; not include FEATURE &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;same as --enable-FEATURE&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;no&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  --enable-FEATURE&lt;span class=&quot;o&quot;&gt;[=&lt;/span&gt;ARG&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;  include FEATURE &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ARG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;yes&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --enable-shared&lt;span class=&quot;o&quot;&gt;[=&lt;/span&gt;PKGS&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;  build shared libraries &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;yes&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --enable-static&lt;span class=&quot;o&quot;&gt;[=&lt;/span&gt;PKGS&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;  build static libraries &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;yes&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --enable-fast-install&lt;span class=&quot;o&quot;&gt;[=&lt;/span&gt;PKGS&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
                          optimize &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; fast installation &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;yes&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --disable-dependency-tracking  speeds up one-time build
  --enable-dependency-tracking   &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; not reject slow dependency extractors
  --disable-libtool-lock  avoid locking &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;might &lt;span class=&quot;nb&quot;&gt;break &lt;/span&gt;parallel builds&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  --enable-xenomai        build the Xenomai interface
  --enable-posix          build the POSIX non-RT interface
  --enable-debug          turn on debugging
  --enable-comedi         build the comedi driver
  --enable-analogy        build the analogy driver
  --enable-ni             build the ni driver
  --enable-clampprotocol     build the clamp protocol module &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;enabled&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

Optional Packages:
  --with-PACKAGE&lt;span class=&quot;o&quot;&gt;[=&lt;/span&gt;ARG&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;    use PACKAGE &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ARG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;yes&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --without-PACKAGE       &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; not use PACKAGE &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;same as --with-PACKAGE&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;no&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  --with-cppunit-prefix&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;PFX   Prefix where CppUnit is installed &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;optional&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  --with-cppunit-exec-prefix&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;PFX  Exec prefix where CppUnit is installed &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;optional&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  --with-pic              try to use only PIC/non-PIC objects &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;use
                          both&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --with-gnu-ld           assume the C compiler uses GNU ld &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;no&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  --with-x                use the X Window System
  --with-Qt-dir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR       DIR is equal to &lt;span class=&quot;nv&quot;&gt;$QTDIR&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; you have followed the
                          installation instructions of Trolltech. Header files
                          are in DIR/include, binary utilities are in DIR/bin.
                          The library is in DIR/lib, unless --with-Qt-lib-dir
                          is also set.
  --with-Qt-include-dir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR
                          Qt header files are in DIR
  --with-Qt-bin-dir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR   Qt utilities such as moc and uic are in DIR
  --with-Qt-lib-dir&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DIR   The Qt library is in DIR
  --with-Qt-lib&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;LIB       Use -lLIB to link with the Qt library
  --with-rtai-config&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;FILE location of the rtai-config program

Some influential environment variables:
  CC          C compiler &lt;span class=&quot;nb&quot;&gt;command&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;  &lt;/span&gt;CFLAGS      C compiler flags
  LDFLAGS     linker flags, e.g. -L &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; you have libraries in a
              nonstandard directory 
  LIBS        libraries to pass to the linker, e.g. -l
  CPPFLAGS    C/C++/Objective C preprocessor flags, e.g. -I &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;
              you have headers in a nonstandard directory 
  CPP         C preprocessor
  CXX         C++ compiler &lt;span class=&quot;nb&quot;&gt;command&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;  &lt;/span&gt;CXXFLAGS    C++ compiler flags
  CXXCPP      C++ preprocessor
  XMKMF       Path to xmkmf, Makefile generator &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; X Window System&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If there is a flag you want to set, say, &lt;code&gt;--enable-ni&lt;/code&gt;, go to the base of the RTXI git directory and run:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./configure --enable-ni
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make -j&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;nproc&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;sudo make install -j&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;nproc&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;These three lines will apply your desired confguration to the build options and then compile and install RTXI.&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Dec 2014 00:00:00 -0500</pubDate>
        <link>http://rtxi.org//docs/tutorials/2014/12/04/manually-configuring-rtxi/</link>
        <guid isPermaLink="true">http://rtxi.org//docs/tutorials/2014/12/04/manually-configuring-rtxi/</guid>
      </item>
    
      <item>
        <title>Desktop Freezes when Booting into the Live CD</title>
        <description>&lt;p&gt;On some machines, the desktop will start out frozen when booted into the Live CD. A workaround is to reboot the system. From the frozen screen, type in &lt;code&gt;Ctrl+Alt+F2&lt;/code&gt;. This will open tty2, which will not be frozen.  &lt;/p&gt;

&lt;p&gt;Login to the new tty. The username is “user” and the password is “live.” Run:&lt;br /&gt;
&lt;code&gt;
$ sudo reboot
&lt;/code&gt;  &lt;/p&gt;

&lt;p&gt;Your system will reboot and magically will no longer be frozen. We’ll work on a fix to make this workaround unecessary after we figure out why this even happens.  &lt;/p&gt;
</description>
        <pubDate>Thu, 04 Dec 2014 00:00:00 -0500</pubDate>
        <link>http://rtxi.org//docs/troubleshoot/2014/12/04/live-cd-frozen/</link>
        <guid isPermaLink="true">http://rtxi.org//docs/troubleshoot/2014/12/04/live-cd-frozen/</guid>
      </item>
    
      <item>
        <title>Can I run RTXI in non-real-time?</title>
        <description>&lt;p&gt;RTXI can be run in non-real-time to debug your code. This will require that you manually configure and recompile RTXI. In the RTXI directory, go to the scripts directory and run:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;sudo ./install-rtxi.sh&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You will be prompted to enter your system configuration. Select “2” to run in non-real-time (POSIX). &lt;/p&gt;

&lt;p&gt;Running RTXI in non-real-time is useful for debugging purposes mainly, and it also allows the application to be installed without having to install a real-time kernel beforehand.&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Dec 2014 00:00:00 -0500</pubDate>
        <link>http://rtxi.org//docs/faqs/2014/12/04/can-i-run-rtxi-in-non-real-time/</link>
        <guid isPermaLink="true">http://rtxi.org//docs/faqs/2014/12/04/can-i-run-rtxi-in-non-real-time/</guid>
      </item>
    
      <item>
        <title>Benchmarking Real-time Performance</title>
        <description>&lt;p&gt;Here is a list of tools for benchmarking real-time performance, both for the operating system and for the RTXI application itself. In general, you should use these to test newly installed kernels, but you can also use them to help diagnose performance issues experienced when running RTXI.  &lt;/p&gt;

&lt;h3 id=&quot;xenomai-based-tests&quot;&gt;Xenomai-based Tests&lt;/h3&gt;
&lt;p&gt;Xenomai comes with benchmarking tools for both real-time and user-space kernels. They are accessible from &lt;code&gt;/usr/xenomai/bin&lt;/code&gt;   &lt;/p&gt;

&lt;h4 id=&quot;latency-test&quot;&gt;Latency Test&lt;/h4&gt;
&lt;p&gt;This test will verify the overall performance of your system and is the best indicator of your real-time performance. It will immediately let you know if you have successfully installed a correctly functioning real-time kernel. In oneshot mode, it measures the difference in time between the expected switch time and the time when a task is actually called by the scheduler. This test prints one line every second and gives you the minimum, average, and maximum latencies for that period as well the minimum and maximum overall latencies that occurred over the entire test. Open up some other programs, copy some files from one location to another, and load the network connection to see how it affects the latency. You should find slightly higher latencies with the user space test than the kernel space test.  &lt;/p&gt;

&lt;p&gt;Your real-time performance is limited by the maximum latency (lat max) you can achieve and you generally don’t want to be doing other tasks. You also should not see any overruns, which occurs when the latency completely exceeds your nominal period. Negative time in the latency test is due to the fact that RTAI performs a calibration at startup that tries to minimize the jitter in the real-time task and anticipates the call. To calibrate for negative latencies, run: &lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# echo 0 &amp;gt; /proc/xenomai/latency&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If you periodically see an overrun (perhaps every 64 seconds) that results in a maximum latency of several hundred microseconds, you may have an SMI (System Maintenance Interrupt) issue. This feature can be found on certain chipsets e.g. Intel 82845 845. Disabling SMI can cause some computers to overheat and may damage those computers. Other “latency killers” are: heavy DMA activities (using the hard disk), using an accelerated X-server, USB legacy support, power management (APM and ACPI), and CPU frequency scaling. If you have disabled all of these in the kernel already, check your BIOS and see if you can disable them there.  &lt;/p&gt;

&lt;h4 id=&quot;preempt-test&quot;&gt;Preempt Test&lt;/h4&gt;
&lt;p&gt;This test is a stress utility that verifies the real-time schedulers under heavy processing load. This software combines the latency calibration task with a fast and slow task to have two levels of preemption.  &lt;/p&gt;

&lt;h4 id=&quot;switch-test&quot;&gt;Switch Test&lt;/h4&gt;
&lt;p&gt;This test provides information about the maximum amount of time RTAI needs to disable interrupts. The test uses a repeated sequence of suspend/resume and semaphore signal/wait calls under a heavy processing load. The switching time should be less than the maximum latency time. The real latency limitation is seldom due to RTAI but an intrinsic drawback of using a general purpose CPU for real-time applications.  &lt;/p&gt;

&lt;h3 id=&quot;rtxi-based-tests&quot;&gt;RTXI-based Tests&lt;/h3&gt;
&lt;p&gt;Internal RTXI performance benchmarks are still in development. Currently, the performance_measurement module can be used to track the accumulated average cycle time and the accumulated average computation time and compare them to the nominal real-time period.  &lt;/p&gt;

&lt;p&gt;The performance measurement module is included in RTXI by default, under the System heading in the menubar. Running it while running modules versus nothing else will show you the performance cost your modules. If you see high computation times relative to your real-time period, consider increading your RT period or simplifying your module(s). &lt;/p&gt;
</description>
        <pubDate>Thu, 04 Dec 2014 00:00:00 -0500</pubDate>
        <link>http://rtxi.org//docs/troubleshoot/2014/12/04/benchmarking-real-time-performance/</link>
        <guid isPermaLink="true">http://rtxi.org//docs/troubleshoot/2014/12/04/benchmarking-real-time-performance/</guid>
      </item>
    
      <item>
        <title>32 or 64 Bit? Your Processor Explained</title>
        <description>&lt;p&gt;64-bit and 32-bit refer to how addresses and memory are handled in different instruction set architectures. For clarity, the terms ‘32-bit’ and ‘64-bit’ have dual meanings. The first refers to the size of addressable chunks of memory. Memory is organized in chunks, called words, that a processor can handle at once. 32 and 64-bit systems respectively handle chunks of memory that are 32 and 64 bits in size. The second meaning refers to the size of the addresses used to catalog all of the addressable points in memory. In other words, each word in memory has an address that the processor uses to find it. 32-bit systems use 32-bit-long addresses, and the same follows for 64-bit ones. Note that it just so happens that these systems have the same address size and word size. It’s not necessarily the case. For instance, early PCs often had 8-bit words and 16-bit addresses.  &lt;/p&gt;

&lt;p&gt;Most commercially available systems today come with 64-bit capable processors and pre-installed 64-bit operating systems. 32-bit applications are compatible with them because the 64-bit format is backwards-compatible. The space addressable by 32 bits is a subset of what is addressed with 64, and the processors are built to handle 32-bit chunks of memory. Simply put, if you have a 64-bit compatible processor, run 64-bit software.  &lt;/p&gt;

&lt;p&gt;One extra consideration is the operating system. Applications other than drivers and similar software interface with the hardware through the operating system. Therefore, it is important to consider the type of operating system installed. 32-bit OSes can only handle 32-bit operations, but 64-bit ones can properly use both.  &lt;/p&gt;

&lt;p&gt;Altogether, none of this is likely to be an issue with machines from the past few years. Lately, AMD and Intel have introduced different brand names and code names for their processors, which can get confusing quite easily. In case you’re running older hardware, here’s a list of a few 64-bit capable processors.&lt;/p&gt;

&lt;div class=&quot;col-md-6&quot;&gt;  
&lt;strong&gt;AMD&lt;/strong&gt; (aka &quot;x86-64&quot;, &quot;AMD64&quot;, or &quot;x64&quot;):  
&lt;ol&gt;
   &lt;li&gt; Athlon 64  &lt;/li&gt;
   &lt;li&gt; AMD Athlon 64 X2 &lt;/li&gt;
   &lt;li&gt; AMD Athlon 64 FX &lt;/li&gt;
   &lt;li&gt; AMD Athlon II (X2/X3/X4) &lt;/li&gt;
   &lt;li&gt; AMD Opteron &lt;/li&gt;
   &lt;li&gt; AMD Turion 64 &lt;/li&gt;
   &lt;li&gt; AMD Turion 64 X2 &lt;/li&gt;
   &lt;li&gt; AMD Sempron (&quot;Palermo&quot; E6 stepping and all &quot;Manila&quot; models) &lt;/li&gt;
   &lt;li&gt; AMD Phenom (X2/X3/X4) &lt;/li&gt;
   &lt;li&gt; AMD Phenom II (X2/X3/X4) &lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

&lt;div class=&quot;col-md-6&quot;&gt;  
&lt;strong&gt;Intel&lt;/strong&gt; (aka &quot;IA-32e&quot;, &quot;EM64T&quot;, or &quot;Intel 64&quot;):   
&lt;ol&gt;
   &lt;li&gt; Netburst family &lt;/li&gt;
   &lt;li&gt; some Celeron D&#39;s: LGA 775 &quot;Prescott&quot; models &lt;/li&gt;
   &lt;li&gt; some Pentium 4&#39;s: &quot;Prescott 2M,&quot; &quot;Irwindale&quot; &quot;Cedar Mill&quot; &lt;/li&gt;
   &lt;li&gt; Pentium D &lt;/li&gt;
   &lt;li&gt; Pentium Extreme Edition &lt;/li&gt;
   &lt;li&gt; Intel Core &lt;/li&gt;
   &lt;li&gt; Xeon: Core 2, Dual Core, Celeron &lt;/li&gt;
   &lt;li&gt; Nehalem: Core i3, i5, i7, Intel Atom &lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 04 Dec 2014 00:00:00 -0500</pubDate>
        <link>http://rtxi.org//docs/tutorials/2014/12/04/32-or-64-bit-processors/</link>
        <guid isPermaLink="true">http://rtxi.org//docs/tutorials/2014/12/04/32-or-64-bit-processors/</guid>
      </item>
    
      <item>
        <title>How do I use more than one DAQ?</title>
        <description>&lt;p&gt;RTXI has no built-in software limitations on the number of DAQ cards. You will need to edit the configuration file, however. Here is the relevant excerpt of /etc/rtxi.conf:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;OBJECT&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;component=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;plugin&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;library=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;comedi_driver.so&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;2&amp;quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;PARAM&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;0&amp;quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;/dev/comedi0&lt;span class=&quot;nt&quot;&gt;&amp;lt;/PARAM&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;PARAM&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Num Devices&amp;quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/PARAM&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;OBJECT&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;13&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;0&amp;quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/OBJECT&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Edit the lines to add another COMEDI device and change the number of devices:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;PARAM&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;0&amp;quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;/dev/comedi0&lt;span class=&quot;nt&quot;&gt;&amp;lt;/PARAM&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;PARAM&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;0&amp;quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;/dev/comedi1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/PARAM&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;PARAM&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Num Devices&amp;quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;2&lt;span class=&quot;nt&quot;&gt;&amp;lt;/PARAM&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This applies to the COMEDI drivers that come with RTAI and haven’t been tested with ANALOGY. In theory, it’ll work. Just replace “comedi” with “analogy” in the names. &lt;/p&gt;

</description>
        <pubDate>Wed, 03 Dec 2014 00:00:00 -0500</pubDate>
        <link>http://rtxi.org//docs/faqs/2014/12/03/how-do-i-use-more-than-one-daq/</link>
        <guid isPermaLink="true">http://rtxi.org//docs/faqs/2014/12/03/how-do-i-use-more-than-one-daq/</guid>
      </item>
    
      <item>
        <title>Can I use RTAI instead of Xenomai?</title>
        <description>&lt;p&gt;Yes, you can use RTAI. Before v2.0, RTXI ran on an RTAI-patched kernel. Xenomai is actually a fork of RTAI and is designed to be much easier to customize and patch. To use RTXI, you will not be able to run our install_rtxi.sh script. Instead, you will need to download RTAI and patch then install a kernel manually.  &lt;/p&gt;

&lt;p&gt;Once you have the kernel running, go to your RTXI git directory and run:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;sh autogen.sh
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./configure --enable-rtai
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;sudo make install&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

</description>
        <pubDate>Wed, 03 Dec 2014 00:00:00 -0500</pubDate>
        <link>http://rtxi.org//docs/faqs/2014/12/03/can-i-use-rtai-instead-of-xenomai/</link>
        <guid isPermaLink="true">http://rtxi.org//docs/faqs/2014/12/03/can-i-use-rtai-instead-of-xenomai/</guid>
      </item>
    
      <item>
        <title>Can I use a different Linux distribution?</title>
        <description>&lt;p&gt;Yes. RTXI has been successfully installed on Ubuntu, openSUSE, Debian, and Fedora. Keep in mind that we use Debian for bugtesting, benchmarking, etc. and that different distributions have different ways of automating scripts, inserting kernel modules, and escalating priveleges. &lt;/p&gt;
</description>
        <pubDate>Wed, 03 Dec 2014 00:00:00 -0500</pubDate>
        <link>http://rtxi.org//docs/faqs/2014/12/03/can-i-use-a-different-linux-distro/</link>
        <guid isPermaLink="true">http://rtxi.org//docs/faqs/2014/12/03/can-i-use-a-different-linux-distro/</guid>
      </item>
    
      <item>
        <title>Combined action potential- and dynamic-clamp for accurate computational modelling of the cardiac IKr current</title>
        <description>&lt;p&gt;In the present work Action-Potential clamp (APC) and Dynamic clamp (DC) were used in combination in order to optimize the Luo–Rudy (LRd) mathematical formulation of the guinea-pig rapid delayed rectifier K+ current (IKr), and to validate the optimized model. To this end, IKr model parameters were adjusted to fit the experimental E4031-sensitive current (IE4031) recorded under APC in guinea-pig myocytes. Currents generated by LRd model (ILRd) and the optimized one (IOpt) were then compared by testing their suitability to replace IE4031 under DC.&lt;/p&gt;

&lt;p&gt;Under APC, ILRd was significantly larger than IE4031 (mean current densities 0.51 ± 0.01 vs 0.21 ± 0.05 pA/pF; p &amp;lt; 0.001), mainly because of different rectification. IOpt mean density (0.17 ± 0.01 pA/pF) was similar to the IE4031 one (NS); moreover, IOpt accurately reproduced IE4031 distribution along the different AP phases. Models were then compared under DC by blocking native IKr (5 μM E4031) and replacing it with ILRd or IOpt. Whereas injection of ILRd overshortened AP duration (APD90) (by 25% of its pre-block value), IOpt injection restored AP morphology and duration to overlap pre-block values.&lt;/p&gt;

&lt;p&gt;This study highlights the power of APC and DC for the identification of reliable formulations of ionic current models. An optimized model of IKr has been obtained which fully reversed E4031 effects on the AP. The model strongly diverged from the widely used Luo–Rudy formulation; this can be particularly relevant to the in silico analysis of AP prolongation caused by IKr blocking or alterations.&lt;/p&gt;
</description>
        <pubDate>Tue, 18 Nov 2014 00:00:00 -0500</pubDate>
        <link>http://rtxi.org//papers/2014/11/18/combined-action-potential-and-dynamic-clamp-for-accurate-computational-modelling-of-the-cardiac-ikr-current/</link>
        <guid isPermaLink="true">http://rtxi.org//papers/2014/11/18/combined-action-potential-and-dynamic-clamp-for-accurate-computational-modelling-of-the-cardiac-ikr-current/</guid>
      </item>
    
      <item>
        <title>Membrane potential-dependent integration of synaptic inputs in entorhinal stellate neurons</title>
        <description>&lt;p&gt;Stellate cells (SCs) of the medial entorhinal cortex exhibit robust spontaneous membrane-potential oscillations (MPOs) in the theta (4–12 Hz) frequency band as well as theta-frequency resonance in their membrane impedance spectra. Past experimental and modeling work suggests that these features may contribute to the phase-locking of SCs to the entorhinal theta rhythm and may be important for forming the hexagonally tiled grid cell place fields exhibited by these neurons in vivo. Among the major biophysical mechanisms contributing to MPOs is a population of persistent (non-inactivating or slowly inactivating) sodium channels. The resulting persistent sodium conductance (GNaP) gives rise to an apparent increase in input resistance as the cell approaches threshold. In this study, we used dynamic clamp to test the hypothesis that this increased input resistance gives rise to voltage-dependent, and thus MPO phase-dependent, changes in the amplitude of excitatory and inhibitory post-synaptic potential (PSP) amplitudes. We find that PSP amplitude depends on membrane potential, exhibiting a 5–10% increase in amplitude per mV depolarization. The effect is larger than—and sums quasi-linearly with—the effect of the synaptic driving force, V - Esyn. Given that input-driven MPOs 10 mV in amplitude are commonly observed in MEC stellate cells in vivo, this voltage- and phase-dependent synaptic gain is large enough to modulate PSP amplitude by over 50% during theta-frequency MPOs. Phase-dependent synaptic gain may therefore impact the phase locking and phase precession of grid cells in vivo to ongoing network oscillations. © 2014 Wiley Periodicals, Inc.&lt;/p&gt;
</description>
        <pubDate>Fri, 25 Jul 2014 00:00:00 -0400</pubDate>
        <link>http://rtxi.org//papers/2014/07/25/membrane-potential-dependent-integration-of-synaptic-inputs-in-entorhinal-stellate-neurons/</link>
        <guid isPermaLink="true">http://rtxi.org//papers/2014/07/25/membrane-potential-dependent-integration-of-synaptic-inputs-in-entorhinal-stellate-neurons/</guid>
      </item>
    
      <item>
        <title>Functional identification of an antennal lobe DM4 projection neuron of the fruit fly</title>
        <description>&lt;p&gt;A rich set of genetic tools and extensive anatomical data make the olfactory system of the fruit fly a neural circuit of choice for studying function in sensory systems. Though a substantial amount of work has been published on the neural coding of olfactory sensory neurons (OSNs) of the fruit fly, yet little is known how projection neurons (PNs) encode time-varying odor stimuli [1]. Here we address this question with in vivo experiments coupled with a phenomenological characterization of the spiking activity of PNs.&lt;/p&gt;

&lt;p&gt;Recently, a new class of identification algorithms called Channel Identification Machines (CIMs) [2] was proposed for identifying dendritic processing in simple neural circuits using conditional phase response curves (cPRCs) [3]. By combining cPRCs with the reduced project-integrated-and-fire neuron (PIF) model [4], the CIM algorithms identify a complete phenomenological description of spike generation of a biological neuron for weak to moderately strong stimuli. Moreover, the identification method employed does not require white noise stimuli nor an infinitesimal pulse injection protocol as widely used in the past [5]. &lt;/p&gt;

&lt;p&gt;Here we identify the PNs both in silico and in vivo. Starting with simulations, we investigate the feasibility of the CIM method on PNs modeled as pseudo uni-polar neurons in silico, as shown in Figures 1.(B) and 1.(C). We then systematically convert the CIM method into a step-by-step experimental protocol, and carry it out in vivo by injecting currents into PNs using the patch clamping technique [6,7]. A snapshot of PN patching is depicted in Figure 1.(A). &lt;/p&gt;
</description>
        <pubDate>Tue, 01 Jul 2014 00:00:00 -0400</pubDate>
        <link>http://rtxi.org//papers/2014/07/01/functional-identification-of-an-antennal-lobe-dm4-projection-neuron-of-the-fruit-fly/</link>
        <guid isPermaLink="true">http://rtxi.org//papers/2014/07/01/functional-identification-of-an-antennal-lobe-dm4-projection-neuron-of-the-fruit-fly/</guid>
      </item>
    
      <item>
        <title>Dynamic Clamp in Cardiac and Neuronal Systems Using RTXI</title>
        <description>&lt;p&gt;The injection of computer-simulated conductances through the dynamic clamp technique has allowed researchers to probe the intercellular and intracellular dynamics of cardiac and neuronal systems with great precision. By coupling computational models to biological systems, dynamic clamp has become a proven tool in electrophysiology with many applications, such as generating hybrid networks in neurons or simulating channelopathies in cardiomyocytes. While its applications are broad, the approach is straightforward: synthesizing traditional patch clamp, computational modeling, and closed-loop feedback control to simulate a cellular conductance. Here, we present two example applications: artificial blocking of the inward rectifier potassium current in a cardiomyocyte and coupling of a biological neuron to a virtual neuron through a virtual synapse. The design and implementation of the necessary software to administer these dynamic clamp experiments can be difficult. In this chapter, we provide an overview of designing and implementing a dynamic clamp experiment using the Real-Time eXperiment Interface (RTXI), an open-source software system tailored for real-time biological experiments. We present two ways to achieve this using RTXI’s modular format, through the creation of a custom user-made module and through existing modules found in RTXI’s online library.&lt;/p&gt;

</description>
        <pubDate>Fri, 20 Jun 2014 00:00:00 -0400</pubDate>
        <link>http://rtxi.org//papers/2014/06/20/dynamic-clamp-in-cardiac-and-neuronal-systems-using-rtxi/</link>
        <guid isPermaLink="true">http://rtxi.org//papers/2014/06/20/dynamic-clamp-in-cardiac-and-neuronal-systems-using-rtxi/</guid>
      </item>
    
      <item>
        <title>Voltage and Calcium Dynamics Both Underlie Cellular Alternans in Cardiac Myocytes</title>
        <description>&lt;p&gt;Cardiac alternans, a putative trigger event for cardiac reentry, is a beat-to-beat alternation in membrane potential and calcium transient. Alternans was originally attributed to instabilities in transmembrane ion channel dynamics (i.e., the voltage mechanism). As of this writing, the predominant view is that instabilities in subcellular calcium handling are the main underlying mechanism. That being said, because the voltage and calcium systems are bidirectionally coupled, theoretical studies have suggested that both mechanisms can contribute. To date, to our knowledge, no experimental evidence of such a dual role within the same cell has been reported. Here, a combined electrophysiological and calcium imaging approach was developed and used to illuminate the contributions of voltage and calcium dynamics to alternans. An experimentally feasible protocol, quantification of subcellular calcium alternans and restitution slope during cycle-length ramping alternans control, was designed and validated. This approach allows simultaneous illumination of the contributions of voltage and calcium-driven instability to total cellular instability as a function of cycle-length. Application of this protocol in in vitro guinea-pig left-ventricular myocytes demonstrated that both voltage- and calcium-driven instabilities underlie alternans, and that the relative contributions of the two systems change as a function of pacing rate.&lt;/p&gt;
</description>
        <pubDate>Wed, 21 May 2014 00:00:00 -0400</pubDate>
        <link>http://rtxi.org//papers/2014/05/21/voltage-and-calcium-dynamics-both-underlie-cellular-alternans-in-cardiac-myocytes/</link>
        <guid isPermaLink="true">http://rtxi.org//papers/2014/05/21/voltage-and-calcium-dynamics-both-underlie-cellular-alternans-in-cardiac-myocytes/</guid>
      </item>
    
      <item>
        <title>Predicting the Responses of Repetitively Firing Neurons to Current Noise</title>
        <description>&lt;p&gt;We used phase resetting methods to predict firing patterns of rat subthalamic nucleus (STN) neurons when their rhythmic firing was densely perturbed by noise. We applied sequences of contiguous brief (0.5–2 ms) current pulses with amplitudes drawn from a Gaussian distribution (10–100 pA standard deviation) to autonomously firing STN neurons in slices. Current noise sequences increased the variability of spike times with little or no effect on the average firing rate. We measured the infinitesimal phase resetting curve (PRC) for each neuron using a noise-based method. A phase model consisting of only a firing rate and PRC was very accurate at predicting spike timing, accounting for more than 80% of spike time variance and reliably reproducing the spike-to-spike pattern of irregular firing. An approximation for the evolution of phase was used to predict the effect of firing rate and noise parameters on spike timing variability. It quantitatively predicted changes in variability of interspike intervals with variation in noise amplitude, pulse duration and firing rate over the normal range of STN spontaneous rates. When constant current was used to drive the cells to higher rates, the PRC was altered in size and shape and accurate predictions of the effects of noise relied on incorporating these changes into the prediction. Application of rate-neutral changes in conductance showed that changes in PRC shape arise from conductance changes known to accompany rate increases in STN neurons, rather than the rate increases themselves. Our results show that firing patterns of densely perturbed oscillators cannot readily be distinguished from those of neurons randomly excited to fire from the rest state. The spike timing of repetitively firing neurons may be quantitatively predicted from the input and their PRCs, even when they are so densely perturbed that they no longer fire rhythmically.&lt;/p&gt;
</description>
        <pubDate>Thu, 08 May 2014 00:00:00 -0400</pubDate>
        <link>http://rtxi.org//papers/2014/05/08/predicting-the-responses-of-repetitively-firing-neurons-to-current-noise/</link>
        <guid isPermaLink="true">http://rtxi.org//papers/2014/05/08/predicting-the-responses-of-repetitively-firing-neurons-to-current-noise/</guid>
      </item>
    
      <item>
        <title>The Past, Present, and Future of Real-Time Control in Cellular Electrophysiology</title>
        <description>&lt;p&gt;For over 60 years, real-time control has been an important technique in the study of excitable cells. Two such control-based technologies are reviewed here. First, voltage-clamp methods revolutionized the study of excitable cells. In this family of techniques, membrane potential is controlled, allowing one to parameterize a powerful class of models that describe the voltage-current relationship of cell membranes simply, flexibly, and accurately. Second, dynamic-clamp methods allow the addition of new, “virtual” membrane mechanisms to living cells. Dynamic clamp allows researchers unprecedented ways of testing computationally based hypotheses in biological preparations. The review ends with predictions of how control-based technologies will be improved and adapted for new uses in the near future.&lt;/p&gt;
</description>
        <pubDate>Thu, 01 May 2014 00:00:00 -0400</pubDate>
        <link>http://rtxi.org//papers/2014/05/01/the-past-present-and-future-of-real-time-control-in-cellular-electrophysiology/</link>
        <guid isPermaLink="true">http://rtxi.org//papers/2014/05/01/the-past-present-and-future-of-real-time-control-in-cellular-electrophysiology/</guid>
      </item>
    
      <item>
        <title>Tonic current through GABAA receptors and hyperpolarization-activated cyclic nucleotide-gated channels modulate resonance properties of rat subicular pyramidal neurons</title>
        <description>&lt;p&gt;The subiculum, considered to be the output structure of the hippocampus, modulates information flow from the hippocampus to various cortical and sub-cortical areas such as the nucleus accumbens, lateral septal region, thalamus, nucleus gelatinosus, medial nucleus and mammillary nuclei. Tonic inhibitory current plays an important role in neuronal physiology and pathophysiology by modulating the electrophysiological properties of neurons. While the alterations of various electrical properties due to tonic inhibition have been studied in neurons from different regions, its influence on intrinsic subthreshold resonance in pyramidal excitatory neurons expressing hyperpolarization-activated cyclic nucleotide-gated (HCN) channels is not known. Using pharmacological agents, we show the involvement of α5βγ GABAA receptors in the picrotoxin-sensitive tonic current in subicular pyramidal neurons. We further investigated the contribution of tonic conductance in regulating subthreshold electrophysiological properties using current clamp and dynamic clamp experiments. We demonstrate that tonic GABAergic inhibition can actively modulate subthreshold properties, including resonance due to HCN channels, which can potentially alter the response dynamics of subicular pyramidal neurons in an oscillating neuronal network.&lt;/p&gt;
</description>
        <pubDate>Thu, 10 Apr 2014 00:00:00 -0400</pubDate>
        <link>http://rtxi.org//papers/2014/04/10/tonic-current-through-gabaa-receptors-and-hyperpolarization-activated-cyclic-nucleotide-gated-channels-modulate-resonance-properties-of-rat-subicular-pyramidal-neurons/</link>
        <guid isPermaLink="true">http://rtxi.org//papers/2014/04/10/tonic-current-through-gabaa-receptors-and-hyperpolarization-activated-cyclic-nucleotide-gated-channels-modulate-resonance-properties-of-rat-subicular-pyramidal-neurons/</guid>
      </item>
    
  </channel>
</rss>
